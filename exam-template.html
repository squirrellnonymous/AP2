<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">Practice Test</title>
    <link rel="stylesheet" href="css/quiz.css">
    <link rel="stylesheet" href="css/exam-print.css" media="print">
</head>
<body>
    <div class="header">
        <div class="header-content">
            <a href="index.html" class="home-link">‚Üê Home</a>
            <div class="header-center">
                <h1 id="quiz-title">Practice Test</h1>
                <div class="progress" id="progress">Loading...</div>
            </div>
            <button id="share-button" class="share-button" onclick="shareExam()" title="Share this exam">
                üì§ Share
            </button>
        </div>
    </div>

    <div class="container">
        <div id="loading" class="loading">
            Loading quiz questions...
        </div>

        <!-- Print-only cover page -->
        <div id="exam-cover-page" class="exam-cover-page">
            <div class="cover-header">
                <h1 id="cover-title">Practice Exam</h1>
                <div class="cover-info">
                    <div class="name-field">
                        <label>Name: _____________________________________________</label>
                    </div>
                    <div class="date-field">
                        <label>Date: _____________________________________________</label>
                    </div>
                </div>
            </div>

            <!-- Scantron-style bubble sheet -->
            <div class="scantron-section">
                <h2>Part I: Multiple Choice</h2>
                <p class="scantron-instructions">Fill in the bubble corresponding to your answer choice.</p>
                <div id="scantron-grid" class="scantron-grid">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <form id="quiz-form" style="display: none;">
            <div id="questions-container"></div>
            <div id="true-make-true-container"></div>
            <div id="table-container"></div>
            <div id="essay-container"></div>
            <button type="button" class="submit-button" onclick="checkAnswers()">Submit Quiz</button>
        </form>

        <div id="results" class="results" style="display:none;">
            <h2>Quiz Results</h2>
            <div id="score" class="score"></div>
            <button type="button" id="calculate-final-score" class="submit-button" onclick="calculateFinalScore()" style="display: none; margin-top: 16px;">Calculate Final Score (with Essays)</button>
            <div id="final-score" class="score" style="display: none; margin-top: 16px;"></div>
        </div>

        <!-- Print-only answer key -->
        <div id="answer-key" class="answer-key">
            <h1 class="answer-key-title">Answer Key</h1>
            <div id="answer-key-content"></div>
        </div>
    </div>

    <script src="https://unpkg.com/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <script src="js/answer-checker.js"></script>
    <script>
        let quizData = null;
        let selectedQuestions = null;

        // Simple markdown parser for explanations
        function parseMarkdown(text) {
            if (!text) return '';

            return text
                // Bold: **text** or __text__
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/__(.+?)__/g, '<strong>$1</strong>')
                // Italic: *text* or _text_
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/_(.+?)_/g, '<em>$1</em>')
                // Inline code: `code`
                .replace(/`(.+?)`/g, '<code>$1</code>')
                // Links: [text](url)
                .replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2" target="_blank">$1</a>');
        }

        // Load quiz data from YAML file
        async function loadQuizData() {
            try {
                // Get exam name from URL parameter, default to unit3-exam3
                const urlParams = new URLSearchParams(window.location.search);
                const examName = urlParams.get('exam') || 'unit3-exam3';

                const response = await fetch(`data/${examName}.yml`);
                const yamlText = await response.text();
                quizData = jsyaml.load(yamlText);

                // Update page title and header
                if (quizData.title) {
                    document.getElementById('page-title').textContent = quizData.title;
                    document.getElementById('quiz-title').innerHTML = quizData.title;
                    document.getElementById('cover-title').innerHTML = quizData.title;
                }

                renderQuiz();
                renderScantron();
                renderAnswerKey();
                updateProgress();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('quiz-form').style.display = 'block';

            } catch (error) {
                console.error('Error loading quiz data:', error);
                const urlParams = new URLSearchParams(window.location.search);
                const examName = urlParams.get('exam') || 'unit3-exam3';
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ef4444; text-align: center;">
                        <h3>Error Loading Quiz</h3>
                        <p>Could not load quiz data for exam: ${examName}</p>
                        <p>Please check that the file exists at: data/${examName}.yml</p>
                        <a href="index.html" style="color: #3b82f6;">‚Üê Back to Home</a>
                    </div>
                `;
            }
        }

        function renderQuiz() {
            if (!quizData || !quizData.multipleChoice) return;

            const container = document.getElementById('questions-container');
            const allQuestions = quizData.multipleChoice;

            // Check if randomization is disabled (default is true for backwards compatibility)
            const shouldRandomize = quizData.randomize !== false;

            if (shouldRandomize) {
                // Get max questions limit (default to all if not specified)
                const maxQuestions = quizData.maxQuestions || allQuestions.length;

                // Group questions by image to keep them together
                const imageGroups = new Map();
                const noImageQuestions = [];

                allQuestions.forEach(q => {
                    if (q.image) {
                        if (!imageGroups.has(q.image)) {
                            imageGroups.set(q.image, []);
                        }
                        imageGroups.get(q.image).push(q);
                    } else {
                        noImageQuestions.push(q);
                    }
                });

                // Convert grouped questions into units (each group or single question is one unit)
                const questionUnits = [];
                const maxQuestionsPerImage = 3; // Limit questions per image to avoid too much scrolling

                imageGroups.forEach(group => {
                    // Shuffle questions within each image group
                    const shuffledGroup = group.sort(() => 0.5 - Math.random());

                    // Split large groups into chunks of maxQuestionsPerImage
                    for (let i = 0; i < shuffledGroup.length; i += maxQuestionsPerImage) {
                        const chunk = shuffledGroup.slice(i, i + maxQuestionsPerImage);
                        questionUnits.push(chunk);
                    }
                });
                noImageQuestions.forEach(q => {
                    questionUnits.push([q]); // Push single questions as one-item arrays
                });

                // Shuffle the units (groups stay together but move around)
                const shuffledUnits = questionUnits.sort(() => 0.5 - Math.random());

                // Flatten and take up to maxQuestions
                selectedQuestions = [];
                for (const unit of shuffledUnits) {
                    if (selectedQuestions.length + unit.length <= maxQuestions) {
                        selectedQuestions.push(...unit);
                    } else if (selectedQuestions.length < maxQuestions) {
                        // Partial unit if we're close to limit
                        const remaining = maxQuestions - selectedQuestions.length;
                        selectedQuestions.push(...unit.slice(0, remaining));
                        break;
                    } else {
                        break;
                    }
                }
            } else {
                // Use all questions in order (no randomization)
                selectedQuestions = allQuestions;
            }

            // Group questions by image for better presentation
            let currentImage = null;
            let questionGroup = null;

            selectedQuestions.forEach((question, index) => {
                // Check if this question has the same image as previous
                if (question.image && question.image === currentImage && questionGroup) {
                    // Add question to existing group
                    const questionItem = document.createElement('div');
                    questionItem.className = 'grouped-question-item';
                    questionItem.innerHTML = `
                        <div class="question-number">Question ${index + 1}</div>
                        <div class="question-text">${question.question}</div>
                        <div class="options">
                            ${question.options.map((option, optionIndex) => `
                                <label class="option">
                                    <input type="radio" name="q${index}" value="${optionIndex}">
                                    <span class="option-text">${String.fromCharCode(97 + optionIndex)}) ${option}</span>
                                </label>
                            `).join('')}
                        </div>
                    `;
                    questionGroup.appendChild(questionItem);
                } else {
                    // Start new card (with or without image)
                    const questionCard = document.createElement('div');
                    questionCard.className = 'question-card';

                    if (question.image) {
                        // Create grouped question container
                        currentImage = question.image;
                        questionGroup = document.createElement('div');
                        questionGroup.className = 'question-group';

                        const imageHTML = `<div class="question-image"><img src="images/${question.image}" alt="Question ${index + 1} diagram" /></div>`;

                        questionCard.innerHTML = imageHTML;

                        const questionItem = document.createElement('div');
                        questionItem.className = 'grouped-question-item';
                        questionItem.innerHTML = `
                            <div class="question-number">Question ${index + 1}</div>
                            <div class="question-text">${question.question}</div>
                            <div class="options">
                                ${question.options.map((option, optionIndex) => `
                                    <label class="option">
                                        <input type="radio" name="q${index}" value="${optionIndex}">
                                        <span class="option-text">${String.fromCharCode(97 + optionIndex)}) ${option}</span>
                                    </label>
                                `).join('')}
                            </div>
                        `;
                        questionGroup.appendChild(questionItem);
                        questionCard.appendChild(questionGroup);
                    } else {
                        // No image - regular single question
                        currentImage = null;
                        questionGroup = null;

                        questionCard.innerHTML = `
                            <div class="question-number">Question ${index + 1}</div>
                            <div class="question-text">${question.question}</div>
                            <div class="options">
                                ${question.options.map((option, optionIndex) => `
                                    <label class="option">
                                        <input type="radio" name="q${index}" value="${optionIndex}">
                                        <span class="option-text">${String.fromCharCode(97 + optionIndex)}) ${option}</span>
                                    </label>
                                `).join('')}
                            </div>
                        `;
                    }

                    container.appendChild(questionCard);
                }
            });

            // Render True/Make True section if it exists
            if (quizData.trueMakeTrue && quizData.trueMakeTrue.length > 0) {
                const tmtContainer = document.getElementById('true-make-true-container');
                tmtContainer.className = 'true-make-true-section';

                const sectionTitle = document.createElement('div');
                sectionTitle.className = 'section-title';
                sectionTitle.textContent = 'Part II: True/Make True';
                tmtContainer.appendChild(sectionTitle);

                const instructions = document.createElement('div');
                instructions.className = 'tmt-instructions';
                instructions.style.textAlign = 'center';
                instructions.style.marginBottom = '20px';
                instructions.style.color = '#6b7280';
                instructions.style.fontSize = '0.9rem';
                instructions.innerHTML = 'If the statement is true, write "True". If false, write the word that makes it true. (2.5 pts each)';
                tmtContainer.appendChild(instructions);

                quizData.trueMakeTrue.forEach((item, index) => {
                    const tmtCard = document.createElement('div');
                    tmtCard.className = 'true-make-true-card';

                    // Process statement to highlight bold/italic words
                    let processedStatement = item.statement.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');

                    tmtCard.innerHTML = `
                        <div class="question-number">Statement ${index + 1} (${item.points || 1} points)</div>
                        <div class="statement-container">
                            <input type="text" class="answer-input" name="tmt${index}" placeholder="Your answer..." autocomplete="off" data-1p-ignore autocorrect="off" autocapitalize="none" spellcheck="false">
                            <div class="statement-text">${processedStatement}</div>
                        </div>
                        <div class="feedback-text" id="tmt-feedback-${index}" style="display: none;"></div>
                    `;

                    tmtContainer.appendChild(tmtCard);
                });
            }

            // Render Essay/Table section if either exists
            if ((quizData.essay && quizData.essay.length > 0) || (quizData.table && quizData.table.length > 0)) {
                const essayContainer = document.getElementById('essay-container');
                essayContainer.className = 'essay-section';

                const sectionTitle = document.createElement('div');
                sectionTitle.className = 'section-title';
                let partNumber = 'II';
                if (quizData.trueMakeTrue && quizData.trueMakeTrue.length > 0) partNumber = 'III';
                sectionTitle.textContent = `Part ${partNumber}: Short/Long Answer`;
                essayContainer.appendChild(sectionTitle);

                const instructions = document.createElement('div');
                instructions.style.textAlign = 'center';
                instructions.style.marginBottom = '20px';
                instructions.style.color = '#6b7280';
                instructions.style.fontSize = '0.9rem';
                instructions.innerHTML = 'Practice essay questions. Any questions left blank will not be graded.';
                essayContainer.appendChild(instructions);

                let questionCounter = 1;

                // Combine table and essay questions, then sort by points (ascending)
                const combinedQuestions = [];

                if (quizData.table && quizData.table.length > 0) {
                    quizData.table.forEach((item, index) => {
                        combinedQuestions.push({ type: 'table', data: item, originalIndex: index });
                    });
                }

                if (quizData.essay && quizData.essay.length > 0) {
                    quizData.essay.forEach((item, index) => {
                        combinedQuestions.push({ type: 'essay', data: item, originalIndex: index });
                    });
                }

                // Sort by points (ascending - smallest first, largest last)
                combinedQuestions.sort((a, b) => (a.data.points || 1) - (b.data.points || 1));

                // Render all questions in sorted order
                combinedQuestions.forEach(({ type, data, originalIndex }) => {
                    if (type === 'table') {
                        const item = data;
                        const index = originalIndex;
                        const tableCard = document.createElement('div');
                        tableCard.className = 'table-card';

                        const headers = item.headers || ['Column 1', 'Column 2'];
                        const numRows = item.answer ? item.answer.length : 3;

                        let tableHTML = `
                            <div class="question-number">Question ${questionCounter} (${item.points} points)</div>
                            <div class="table-question">${item.question}</div>
                            <div class="table-answer-container">
                                <table class="answer-table">
                                    <thead>
                                        <tr>
                                            ${headers.map(header => `<th>${header}</th>`).join('')}
                                        </tr>
                                    </thead>
                                    <tbody>
                        `;

                        // Calculate column widths based on which is prefilled
                        const prefilledCol = item.prefilledColumn !== undefined ? item.prefilledColumn : -1;
                        const numCols = headers.length;
                        let colWidths = [];

                        if (prefilledCol >= 0) {
                            // If there's a prefilled column, give it more space
                            // For 2 columns: 60/40, for 5 columns: 30% for prefilled, rest split evenly
                            if (numCols === 2) {
                                colWidths = prefilledCol === 0 ? ['60%', '40%'] : ['40%', '60%'];
                            } else {
                                const prefilledWidth = 30;
                                const remainingWidth = (100 - prefilledWidth) / (numCols - 1);
                                colWidths = headers.map((_, idx) =>
                                    idx === prefilledCol ? `${prefilledWidth}%` : `${remainingWidth}%`
                                );
                            }
                        } else {
                            // No prefilled column, distribute evenly
                            const evenWidth = 100 / numCols;
                            colWidths = headers.map(() => `${evenWidth}%`);
                        }

                        for (let row = 0; row < numRows; row++) {
                            tableHTML += '<tr>';
                            headers.forEach((header, col) => {
                                const isPrefilled = col === prefilledCol;
                                const prefilledValue = isPrefilled && item.answer && item.answer[row] ? (Array.isArray(item.answer[row]) ? item.answer[row][col] : '') : '';

                                if (isPrefilled) {
                                    tableHTML += `<td style="width: ${colWidths[col]};"><div style="padding: 8px;">${prefilledValue}</div></td>`;
                                } else {
                                    tableHTML += `<td style="width: ${colWidths[col]};"><textarea name="table${index}-${row}-${col}" rows="1" autocomplete="off" autocorrect="off" spellcheck="false" onkeydown="handleTableNavigation(event, ${index}, ${row}, ${col}, ${numRows}, ${headers.length})" oninput="autoGrowTextarea(this)"></textarea></td>`;
                                }
                            });
                            tableHTML += '</tr>';
                        }

                        tableHTML += `
                                    </tbody>
                                </table>
                            </div>
                            <div class="table-answer" id="table-answer-${index}" style="display: none;">
                                <h4>Sample Answer:</h4>
                                <table class="sample-answer-table">
                                    <thead>
                                        <tr>
                                            ${headers.map(header => `<th>${header}</th>`).join('')}
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${item.answer.map(row =>
                                            `<tr>${Array.isArray(row) ? row.map(cell => `<td>${cell}</td>`).join('') : `<td colspan="${headers.length}">${row}</td>`}</tr>`
                                        ).join('')}
                                    </tbody>
                                </table>
                            </div>
                            <div class="table-grading" id="table-grading-${index}" style="display: none;">
                                <h4>Self-Grading:</h4>
                                <div class="points-input-container">
                                    <input type="number" class="points-input" name="table-points-${index}" min="0" max="${item.points}" value="0">
                                    <span class="points-label">/ ${item.points} points</span>
                                </div>
                            </div>
                        `;

                        tableCard.innerHTML = tableHTML;
                        essayContainer.appendChild(tableCard);
                        questionCounter++;
                    } else if (type === 'essay') {
                        const item = data;
                        const index = originalIndex;
                        const essayCard = document.createElement('div');
                        essayCard.className = 'essay-card';

                        const imageHTML = item.image ? `<div class="essay-image"><img src="images/${item.image}" alt="Question ${questionCounter} diagram" /></div>` : '';

                        essayCard.innerHTML = `
                            <div class="question-number">Question ${questionCounter} (${item.points} points)</div>
                            ${imageHTML}
                            <div class="essay-question">${item.question}</div>
                            <textarea class="essay-textarea" name="essay${index}" placeholder="Write your answer here..." autocomplete="off" data-1p-ignore autocorrect="off" spellcheck="true"></textarea>
                            <div class="essay-answer" id="essay-answer-${index}" style="display: none;">
                                <h4>Sample Answer:</h4>
                                <div class="essay-answer-text">${item.answer}</div>
                            </div>
                            <div class="essay-grading" id="essay-grading-${index}" style="display: none;">
                                <h4>Self-Grading:</h4>
                                <div class="points-input-container">
                                    <input type="number" class="points-input" name="essay-points-${index}" min="0" max="${item.points}" value="0">
                                    <span class="points-label">/ ${item.points} points</span>
                                </div>
                            </div>
                        `;

                        essayContainer.appendChild(essayCard);
                        questionCounter++;
                    }
                });
            }

            // Add click handlers to option labels for better UX
            document.querySelectorAll('.option').forEach(option => {
                option.addEventListener('click', function() {
                    const radio = this.querySelector('input[type="radio"]');
                    const name = radio.name;

                    // Remove selected class from all options with same name
                    document.querySelectorAll(`input[name="${name}"]`).forEach(input => {
                        input.closest('.option').classList.remove('selected');
                    });

                    // Add selected class to this option
                    this.classList.add('selected');
                });
            });
        }

        function autoGrowTextarea(textarea) {
            // Reset height to auto to get the correct scrollHeight
            textarea.style.height = 'auto';
            // Set height to scrollHeight to fit content
            textarea.style.height = textarea.scrollHeight + 'px';
        }

        function handleTableNavigation(event, tableIndex, currentRow, currentCol, totalRows, totalCols) {
            if (event.key === 'Enter') {
                event.preventDefault();

                let nextRow = currentRow;
                let nextCol = currentCol + 1;

                // If we're at the end of a row, move to next row, first column
                if (nextCol >= totalCols) {
                    nextRow = currentRow + 1;
                    nextCol = 0;
                }

                // If we're at the end of the table, move to next question
                if (nextRow >= totalRows) {
                    // Try to find the next focusable element (next question)
                    const currentTableCard = event.target.closest('.table-card');
                    const allCards = document.querySelectorAll('.essay-card, .table-card');

                    let foundCurrent = false;
                    for (let card of allCards) {
                        if (foundCurrent) {
                            // Focus the first input/textarea in the next card
                            const nextInput = card.querySelector('input, textarea');
                            if (nextInput) {
                                nextInput.focus();
                                return;
                            }
                        }
                        if (card === currentTableCard) {
                            foundCurrent = true;
                        }
                    }

                    // If no next question found, do nothing (stay in current cell)
                    return;
                }

                // Move to the next cell in the table
                const nextInput = document.querySelector(`textarea[name="table${tableIndex}-${nextRow}-${nextCol}"]`);
                if (nextInput) {
                    nextInput.focus();
                }
            }
        }

        function renderScantron() {
            if (!selectedQuestions) return;

            const scantronGrid = document.getElementById('scantron-grid');
            const numQuestions = selectedQuestions.length;

            // Find the maximum number of options across all questions
            const maxOptions = Math.max(...selectedQuestions.map(q => q.options.length));

            // Determine number of columns (typically 2 columns for scantron)
            const columns = 2;
            const questionsPerColumn = Math.ceil(numQuestions / columns);

            let scantronHTML = '';

            for (let col = 0; col < columns; col++) {
                scantronHTML += '<div class="scantron-column">';

                const startIdx = col * questionsPerColumn;
                const endIdx = Math.min(startIdx + questionsPerColumn, numQuestions);

                for (let i = startIdx; i < endIdx; i++) {
                    const questionNum = i + 1;

                    scantronHTML += `
                        <div class="scantron-row">
                            <span class="scantron-number">${questionNum}.</span>
                            <div class="scantron-bubbles">
                    `;

                    // Create bubbles for all options (A through max option letter)
                    for (let opt = 0; opt < maxOptions; opt++) {
                        const letter = String.fromCharCode(65 + opt); // A=65, B=66, etc.
                        scantronHTML += `
                            <div class="bubble-container">
                                <span class="bubble-letter">${letter}</span>
                                <div class="bubble"></div>
                            </div>
                        `;
                    }

                    scantronHTML += `
                            </div>
                        </div>
                    `;
                }

                scantronHTML += '</div>';
            }

            scantronGrid.innerHTML = scantronHTML;
        }

        function renderAnswerKey() {
            if (!quizData || !selectedQuestions) return;

            const answerKeyContent = document.getElementById('answer-key-content');
            let keyHTML = '';

            // Multiple Choice answers
            if (selectedQuestions && selectedQuestions.length > 0) {
                keyHTML += '<div class="answer-key-section"><h2>Multiple Choice</h2>';
                selectedQuestions.forEach((question, index) => {
                    const correctLetter = String.fromCharCode(65 + question.correct); // A=0, B=1, etc.
                    keyHTML += `<div class="answer-key-item">${index + 1}. ${correctLetter}</div>`;
                });
                keyHTML += '</div>';
            }

            // True/Make True answers
            if (quizData.trueMakeTrue && quizData.trueMakeTrue.length > 0) {
                keyHTML += '<div class="answer-key-section"><h2>True/Make True</h2>';
                quizData.trueMakeTrue.forEach((item, index) => {
                    let answer;
                    if (item.isTrue) {
                        answer = 'True';
                    } else {
                        const correctWords = Array.isArray(item.correctWord) ? item.correctWord : [item.correctWord];
                        answer = correctWords[0]; // Show first correct answer
                    }
                    keyHTML += `<div class="answer-key-item">${index + 1}. ${answer}</div>`;
                });
                keyHTML += '</div>';
            }

            // Table answers
            if (quizData.table && quizData.table.length > 0) {
                keyHTML += '<div class="answer-key-section"><h2>Table Questions</h2>';
                quizData.table.forEach((item, index) => {
                    keyHTML += `<div class="answer-key-item"><strong>Question ${index + 1}:</strong> ${item.question}</div>`;
                    if (item.answer && Array.isArray(item.answer)) {
                        keyHTML += '<div class="answer-key-table">';
                        item.answer.forEach((row, rowIdx) => {
                            if (Array.isArray(row)) {
                                keyHTML += `<div class="answer-key-row">${row.join(' | ')}</div>`;
                            } else {
                                keyHTML += `<div class="answer-key-row">${row}</div>`;
                            }
                        });
                        keyHTML += '</div>';
                    }
                });
                keyHTML += '</div>';
            }

            // Essay answers
            if (quizData.essay && quizData.essay.length > 0) {
                const questionOffset = (quizData.table ? quizData.table.length : 0);
                keyHTML += '<div class="answer-key-section"><h2>Essay/Short Answer</h2>';
                quizData.essay.forEach((item, index) => {
                    keyHTML += `<div class="answer-key-item">
                        <strong>Question ${index + 1 + questionOffset}:</strong> ${item.question}
                    </div>`;
                    keyHTML += `<div class="answer-key-essay">${item.answer}</div>`;
                });
                keyHTML += '</div>';
            }

            answerKeyContent.innerHTML = keyHTML;
        }

        function updateProgress() {
            const mcCount = selectedQuestions ? selectedQuestions.length : 0;
            const tmtCount = quizData.trueMakeTrue ? quizData.trueMakeTrue.length : 0;
            const tableCount = quizData.table ? quizData.table.length : 0;
            const essayCount = quizData.essay ? quizData.essay.length : 0;

            // Calculate total points
            const mcPoints = mcCount; // 1 point each
            const tmtPoints = quizData.trueMakeTrue ? quizData.trueMakeTrue.reduce((sum, item) => sum + (item.points || 1), 0) : 0;
            const tablePoints = quizData.table ? quizData.table.reduce((sum, item) => sum + (item.points || 1), 0) : 0;
            const essayPoints = quizData.essay ? quizData.essay.reduce((sum, item) => sum + (item.points || 1), 0) : 0;
            const totalPoints = mcPoints + tmtPoints + tablePoints + essayPoints;

            let sections = [];

            if (mcCount > 0) {
                sections.push(`${mcCount} Multiple Choice (${mcPoints} pts)`);
            }
            if (tmtCount > 0) {
                sections.push(`${tmtCount} True/Make True (${tmtPoints} pts)`);
            }
            if (tableCount > 0 || essayCount > 0) {
                const combinedCount = tableCount + essayCount;
                const combinedPoints = tablePoints + essayPoints;
                sections.push(`${combinedCount} Short/Long Answer (${combinedPoints} pts)`);
            }

            const progressText = `${totalPoints} Points<br>${sections.join('<br>')}`;
            document.getElementById('progress').innerHTML = progressText;
        }

        function checkAnswers() {
            if (!quizData || !selectedQuestions) return;

            // Check for blank answers before proceeding
            const questions = selectedQuestions;
            let blankMC = 0;
            let blankTMT = 0;
            let blankTable = 0;
            let blankEssay = 0;

            // Count blank multiple choice
            questions.forEach((question, index) => {
                const selected = document.querySelector(`input[name="q${index}"]:checked`);
                if (!selected) blankMC++;
            });

            // Count blank true/make true
            if (quizData.trueMakeTrue) {
                quizData.trueMakeTrue.forEach((item, index) => {
                    const input = document.querySelector(`input[name="tmt${index}"]`);
                    if (!input || !input.value.trim()) blankTMT++;
                });
            }

            // Count blank table questions
            if (quizData.table) {
                quizData.table.forEach((item, index) => {
                    const headers = item.headers || ['Column 1', 'Column 2'];
                    const numRows = item.answer ? item.answer.length : 3;
                    let hasAnyInput = false;

                    for (let row = 0; row < numRows; row++) {
                        for (let col = 0; col < headers.length; col++) {
                            const input = document.querySelector(`textarea[name="table${index}-${row}-${col}"]`);
                            if (input && input.value.trim()) {
                                hasAnyInput = true;
                                break;
                            }
                        }
                        if (hasAnyInput) break;
                    }

                    if (!hasAnyInput) blankTable++;
                });
            }

            // Count blank essays (not included in warning since essays are optional)
            if (quizData.essay) {
                quizData.essay.forEach((item, index) => {
                    const textarea = document.querySelector(`textarea[name="essay${index}"]`);
                    if (!textarea || !textarea.value.trim()) blankEssay++;
                });
            }

            // Show warning if there are blank answers (essays excluded - they're optional)
            if (blankMC > 0 || blankTMT > 0 || blankTable > 0) {
                let warningMessage = "You have unanswered questions:\n\n";
                if (blankMC > 0) warningMessage += `‚Ä¢ ${blankMC} Multiple Choice question${blankMC > 1 ? 's' : ''}\n`;
                if (blankTMT > 0) warningMessage += `‚Ä¢ ${blankTMT} True/Make True question${blankTMT > 1 ? 's' : ''}\n`;
                if (blankTable > 0) warningMessage += `‚Ä¢ ${blankTable} Table question${blankTable > 1 ? 's' : ''}\n`;
                warningMessage += "\nDo you want to submit anyway?";

                if (!confirm(warningMessage)) {
                    return; // Cancel submission
                }
            }

            let mcScore = 0;
            let tmtScore = 0;

            // Check multiple choice questions
            questions.forEach((question, index) => {
                const selected = document.querySelector(`input[name="q${index}"]:checked`);
                const allOptions = document.querySelectorAll(`input[name="q${index}"]`);
                const correctAnswer = question.correct;

                if (selected) {
                    const answer = parseInt(selected.value);

                    // Style all options based on correctness
                    allOptions.forEach((option, optionIndex) => {
                        const optionElement = option.closest('.option');
                        optionElement.classList.remove('selected');

                        if (optionIndex === correctAnswer) {
                            optionElement.classList.add('correct');
                        } else if (option.checked && optionIndex !== correctAnswer) {
                            optionElement.classList.add('incorrect');
                        }
                    });

                    if (answer === correctAnswer) {
                        mcScore += 2;
                        // Show explanation for correct answer if it exists
                        if (question.explanation) {
                            // Find the appropriate container (grouped-question-item or question-card)
                            const groupedItem = allOptions[0].closest('.grouped-question-item');
                            const container = groupedItem || allOptions[0].closest('.question-card');
                            if (container && !container.querySelector('.explanation')) {
                                const explanationDiv = document.createElement('div');
                                explanationDiv.className = 'explanation correct-explanation';
                                explanationDiv.style.cssText = 'margin-top: 16px; padding: 12px; background: #d1fae5; border-left: 4px solid #10b981; color: #065f46; font-size: 0.9rem; line-height: 1.5; border-radius: 4px;';
                                explanationDiv.innerHTML = `<strong>‚úì Explanation:</strong> ${parseMarkdown(question.explanation)}`;
                                container.appendChild(explanationDiv);
                            }
                        }
                    } else {
                        // Show explanation for incorrect answer if it exists
                        if (question.explanation) {
                            // Find the appropriate container (grouped-question-item or question-card)
                            const groupedItem = allOptions[0].closest('.grouped-question-item');
                            const container = groupedItem || allOptions[0].closest('.question-card');
                            if (container && !container.querySelector('.explanation')) {
                                const explanationDiv = document.createElement('div');
                                explanationDiv.className = 'explanation incorrect-explanation';
                                explanationDiv.style.cssText = 'margin-top: 16px; padding: 12px; background: #fcf2f2; border-left: 4px solid #fdafaf; color: #991b1b; font-size: 0.9rem; line-height: 1.5; border-radius: 4px;';
                                explanationDiv.innerHTML = `<strong>Explanation:</strong> ${parseMarkdown(question.explanation)}`;
                                container.appendChild(explanationDiv);
                            }
                        }
                    }
                } else {
                    // Highlight correct answer even if not selected
                    allOptions[correctAnswer].closest('.option').classList.add('correct');

                    // Show explanation for unanswered question if it exists
                    if (question.explanation) {
                        // Find the appropriate container (grouped-question-item or question-card)
                        const groupedItem = allOptions[0].closest('.grouped-question-item');
                        const container = groupedItem || allOptions[0].closest('.question-card');
                        if (container && !container.querySelector('.explanation')) {
                            const explanationDiv = document.createElement('div');
                            explanationDiv.className = 'explanation incorrect-explanation';
                            explanationDiv.style.cssText = 'margin-top: 16px; padding: 12px; background: #fcf2f2; border-left: 4px solid #fdafaf; color: #991b1b; font-size: 0.9rem; line-height: 1.5; border-radius: 4px;';
                            explanationDiv.innerHTML = `<strong>Explanation:</strong> ${parseMarkdown(question.explanation)}`;
                            container.appendChild(explanationDiv);
                        }
                    }
                }
            });

            // Check True/Make True questions
            if (quizData.trueMakeTrue && quizData.trueMakeTrue.length > 0) {
                quizData.trueMakeTrue.forEach((item, index) => {
                    const input = document.querySelector(`input[name="tmt${index}"]`);
                    const feedbackElement = document.getElementById(`tmt-feedback-${index}`);

                    if (input && feedbackElement) {
                        const userAnswer = input.value.trim();
                        const normalizedUserAnswer = normalizeAnswer(userAnswer);
                        let pointsEarned = 0;
                        let isCorrect = false;
                        let isPartial = false;

                        if (item.isTrue) {
                            // Statement is true, accept "true" or "t"
                            isCorrect = normalizedUserAnswer === 'true' || normalizedUserAnswer === 't';
                            if (isCorrect) {
                                pointsEarned = item.points || 1;
                            }
                        } else {
                            // Statement is false, check if they provided the correct word
                            const correctWords = Array.isArray(item.correctWord) ? item.correctWord : [item.correctWord];

                            // First check for exact match (normalized)
                            const exactMatch = correctWords.some(word => normalizedUserAnswer === normalizeAnswer(word));

                            if (exactMatch) {
                                isCorrect = true;
                                pointsEarned = item.points || 1;
                            } else {
                                // Check for fuzzy match (typos)
                                let bestSimilarity = 0;
                                correctWords.forEach(word => {
                                    const similarity = getSimilarityScore(normalizedUserAnswer, normalizeAnswer(word));
                                    if (similarity > bestSimilarity) {
                                        bestSimilarity = similarity;
                                    }
                                });

                                // Award partial credit for close answers (similarity > 0.75)
                                if (bestSimilarity > 0.75) {
                                    isPartial = true;
                                    const fullPoints = item.points || 1;
                                    pointsEarned = fullPoints * 0.5; // 50% credit for typos
                                }
                            }
                        }

                        tmtScore += pointsEarned;

                        if (isCorrect) {
                            input.classList.add('correct');
                            feedbackElement.textContent = 'Correct!';
                            feedbackElement.className = 'feedback-text correct';
                        } else if (isPartial) {
                            input.classList.add('partial');
                            const correctWords = Array.isArray(item.correctWord) ? item.correctWord : [item.correctWord];
                            feedbackElement.innerHTML = `<span style="color: #f59e0b;">Partial credit (typo).</span> <span style="color: #10b981;">Correct: ${correctWords.join(' or ')}</span>`;
                            feedbackElement.className = 'feedback-text partial';
                        } else {
                            input.classList.add('incorrect');
                            if (item.isTrue) {
                                feedbackElement.innerHTML = '<span style="color: #ef4444;">Incorrect.</span> <span style="color: #10b981;">True</span>';
                            } else {
                                const correctWords = Array.isArray(item.correctWord) ? item.correctWord : [item.correctWord];
                                feedbackElement.innerHTML = `<span style="color: #ef4444;">Incorrect.</span> <span style="color: #10b981;">${correctWords.join(' or ')}</span>`;
                            }
                            feedbackElement.className = 'feedback-text';
                        }

                        feedbackElement.style.display = 'block';
                    }
                });
            }

            // Show table answers and grading interface
            if (quizData.table && quizData.table.length > 0) {
                quizData.table.forEach((item, index) => {
                    const answerElement = document.getElementById(`table-answer-${index}`);
                    const gradingElement = document.getElementById(`table-grading-${index}`);

                    // Make table inputs read-only
                    const tableInputs = document.querySelectorAll(`textarea[name^="table${index}-"]`);
                    tableInputs.forEach(input => {
                        input.readOnly = true;
                    });

                    // Show correct answers and grading interface
                    if (answerElement) answerElement.style.display = 'block';
                    if (gradingElement) gradingElement.style.display = 'block';
                });
            }

            // Make all textareas read-only
            if (quizData.essay && quizData.essay.length > 0) {
                quizData.essay.forEach((item, index) => {
                    const textarea = document.querySelector(`textarea[name="essay${index}"]`);
                    if (textarea) {
                        textarea.readOnly = true;
                    }
                });
            }

            // Calculate total score (only MC and TMT are graded automatically)
            const tmtMaxPoints = quizData.trueMakeTrue ? quizData.trueMakeTrue.reduce((sum, item) => sum + (item.points || 1), 0) : 0;
            const gradedPoints = questions.length + tmtMaxPoints;
            const totalScore = mcScore + tmtScore;
            const percentage = Math.round((totalScore / gradedPoints) * 100);

            // Check if any essays or tables were attempted
            let hasAttemptedEssays = false;
            let hasAttemptedTables = false;

            if (quizData.essay) {
                hasAttemptedEssays = quizData.essay.some((item, index) => {
                    const textarea = document.querySelector(`textarea[name="essay${index}"]`);
                    return textarea && textarea.value.trim();
                });
            }

            if (quizData.table) {
                hasAttemptedTables = quizData.table.some((item, index) => {
                    const headers = item.headers || ['Column 1', 'Column 2'];
                    const numRows = item.answer ? item.answer.length : 3;
                    for (let row = 0; row < numRows; row++) {
                        for (let col = 0; col < headers.length; col++) {
                            const input = document.querySelector(`textarea[name="table${index}-${row}-${col}"]`);
                            if (input && input.value.trim()) return true;
                        }
                    }
                    return false;
                });
            }

            let scoreDisplay;
            if (hasAttemptedEssays || hasAttemptedTables) {
                scoreDisplay = `Score: ${totalScore}/${gradedPoints} (${percentage}%)`;
                if (quizData.trueMakeTrue && quizData.trueMakeTrue.length > 0) {
                    scoreDisplay += `<br><small>Multiple Choice: ${mcScore}/${questions.length * 2}<br>True/Make True: ${tmtScore}/${tmtMaxPoints}</small>`;
                }
                scoreDisplay += `<br><br><small style="color: #6b7280;">Opening grading modal for essay/table questions...</small>`;
            } else {
                scoreDisplay = `Score: ${totalScore}/${gradedPoints} (${percentage}%)`;
                if (quizData.trueMakeTrue && quizData.trueMakeTrue.length > 0) {
                    scoreDisplay += `<br><small>Multiple Choice: ${mcScore}/${questions.length * 2}<br>True/Make True: ${tmtScore}/${tmtMaxPoints}</small>`;
                }
            }

            // Clear any selected highlighting
            document.querySelectorAll('.selected').forEach(element => {
                element.classList.remove('selected');
            });

            // Disable all inputs after submission
            document.querySelectorAll('input[type="radio"], textarea').forEach(input => {
                input.disabled = true;
            });

            document.getElementById('score').innerHTML = scoreDisplay;
            document.getElementById('results').style.display = 'block';
            document.querySelector('.submit-button').disabled = true;
            document.querySelector('.submit-button').textContent = 'Quiz Completed';

            // Scroll to results
            document.getElementById('results').scrollIntoView({ behavior: 'smooth' });

            // Launch grading modal if there are attempted essays/tables
            if (hasAttemptedEssays || hasAttemptedTables) {
                setTimeout(() => {
                    showGradingModal();
                }, 500);
            }
        }

        // Essay/Table Grading Modal System
        let currentGradingIndex = 0;
        let gradingItems = [];
        let gradingScores = new Map(); // Store points for each item

        function generateGradingButtons(maxPoints, selectedPoints) {
            const buttons = [];

            // Generate labels based on point value
            const getLabel = (points, max) => {
                if (points === 0) return 'Wrong';
                if (points === max) return 'Perfect';
                if (max === 2) return 'Partial';
                if (max === 3) {
                    if (points === 1) return 'Partial';
                    if (points === 2) return 'Good';
                }
                if (max === 4) {
                    if (points === 1) return 'Poor';
                    if (points === 2) return 'Partial';
                    if (points === 3) return 'Good';
                }
                if (max === 5) {
                    if (points === 1) return 'Poor';
                    if (points === 2) return 'Fair';
                    if (points === 3) return 'Good';
                    if (points === 4) return 'Great';
                }
                // For other values, just show points
                return points;
            };

            // Create buttons for each point value (0 to max)
            for (let i = 0; i <= maxPoints; i++) {
                const label = getLabel(i, maxPoints);
                const ptLabel = i === 1 ? 'pt' : 'pts';
                const isSelected = selectedPoints === i ? 'selected' : '';

                buttons.push(`
                    <button type="button" class="grading-option-btn ${isSelected}" onclick="selectGradingPoints(${i})" data-points="${i}">
                        <span class="grading-btn-label">${label}</span>
                        <span class="grading-btn-points">${i} ${ptLabel}</span>
                    </button>
                `);
            }

            return buttons.join('');
        }

        function selectGradingPoints(points) {
            // Update hidden input
            const hiddenInput = document.getElementById('grading-points-input');
            if (hiddenInput) {
                hiddenInput.value = points;
            }

            // Update button selection states
            document.querySelectorAll('.grading-option-btn').forEach(btn => {
                btn.classList.remove('selected');
                if (parseInt(btn.dataset.points) === points) {
                    btn.classList.add('selected');
                }
            });

            // Save to grading scores
            gradingScores.set(currentGradingIndex, points);
        }

        function showGradingModal() {
            // Build list of items to grade
            gradingItems = [];

            // Combine table and essay questions, then sort by points (ascending)
            const combinedQuestions = [];

            if (quizData.table && quizData.table.length > 0) {
                quizData.table.forEach((item, index) => {
                    combinedQuestions.push({ type: 'table', data: item, originalIndex: index });
                });
            }

            if (quizData.essay && quizData.essay.length > 0) {
                quizData.essay.forEach((item, index) => {
                    combinedQuestions.push({ type: 'essay', data: item, originalIndex: index });
                });
            }

            // Sort by points (ascending - smallest first, largest last)
            combinedQuestions.sort((a, b) => (a.data.points || 1) - (b.data.points || 1));

            // Filter to only attempted items
            combinedQuestions.forEach(({ type, data, originalIndex }) => {
                if (type === 'table') {
                    const headers = data.headers || ['Column 1', 'Column 2'];
                    const numRows = data.answer ? data.answer.length : 3;
                    let hasAnyInput = false;

                    for (let row = 0; row < numRows; row++) {
                        for (let col = 0; col < headers.length; col++) {
                            const input = document.querySelector(`textarea[name="table${originalIndex}-${row}-${col}"]`);
                            if (input && input.value.trim()) {
                                hasAnyInput = true;
                                break;
                            }
                        }
                        if (hasAnyInput) break;
                    }

                    if (hasAnyInput) {
                        gradingItems.push({ type, data, originalIndex });
                    }
                } else if (type === 'essay') {
                    const textarea = document.querySelector(`textarea[name="essay${originalIndex}"]`);
                    if (textarea && textarea.value.trim()) {
                        gradingItems.push({ type, data, originalIndex });
                    }
                }
            });

            // If no items to grade, just calculate final score
            if (gradingItems.length === 0) {
                autoCalculateFinalScore();
                return;
            }

            currentGradingIndex = 0;
            showGradingModalAtIndex(0);
        }

        function showGradingModalAtIndex(index) {
            if (index < 0 || index >= gradingItems.length) return;

            const item = gradingItems[index];
            const isLastItem = index === gradingItems.length - 1;

            // Remove existing modal
            const existingModal = document.querySelector('.grading-modal');
            if (existingModal) {
                existingModal.remove();
            }

            // Create modal
            const modal = document.createElement('div');
            modal.className = 'grading-modal';

            let contentHTML = '';

            if (item.type === 'essay') {
                const textarea = document.querySelector(`textarea[name="essay${item.originalIndex}"]`);
                const studentAnswer = textarea ? textarea.value.trim() : '';
                const imageHTML = item.data.image ? `<div class="grading-image"><img src="images/${item.data.image}" alt="Question diagram" /></div>` : '';

                contentHTML = `
                    <div class="grading-modal-content">
                        <div class="grading-header">
                            <h3>Grade Your Answer</h3>
                            <span class="grading-position">${index + 1} of ${gradingItems.length}</span>
                        </div>
                        ${imageHTML}
                        <div class="grading-question">
                            <strong>Question (${item.data.points} points):</strong>
                            <p>${item.data.question}</p>
                        </div>
                        <div class="grading-your-answer">
                            <strong>Your Answer:</strong>
                            <div class="grading-answer-box">${studentAnswer}</div>
                        </div>
                        <div class="grading-sample-answer">
                            <strong>Sample Answer:</strong>
                            <div class="grading-answer-box grading-sample">${item.data.answer}</div>
                        </div>
                        <div class="grading-points-section">
                            <label class="grading-label">How did your answer compare?</label>
                            <div class="grading-buttons-grid" id="grading-buttons-${index}">
                                ${generateGradingButtons(item.data.points, gradingScores.get(index))}
                            </div>
                            <input type="hidden" id="grading-points-input" value="${gradingScores.get(index) || ''}">
                        </div>
                        <div class="grading-buttons">
                            <button class="grading-btn grading-prev" onclick="navigateGrading(-1)" ${index === 0 ? 'disabled' : ''}>‚Äπ Previous</button>
                            <button class="grading-btn grading-next" onclick="navigateGrading(1)">${isLastItem ? 'Finish Grading ‚Üí' : 'Next ‚Ä∫'}</button>
                        </div>
                    </div>
                `;
            } else if (item.type === 'table') {
                const headers = item.data.headers || ['Column 1', 'Column 2'];
                const numRows = item.data.answer ? item.data.answer.length : 3;

                // Build student's table
                let studentTableHTML = `
                    <table class="grading-table">
                        <thead>
                            <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
                        </thead>
                        <tbody>
                `;

                for (let row = 0; row < numRows; row++) {
                    studentTableHTML += '<tr>';
                    for (let col = 0; col < headers.length; col++) {
                        const input = document.querySelector(`textarea[name="table${item.originalIndex}-${row}-${col}"]`);
                        const value = input ? input.value.trim() : '';
                        studentTableHTML += `<td>${value || '<em>(blank)</em>'}</td>`;
                    }
                    studentTableHTML += '</tr>';
                }

                studentTableHTML += '</tbody></table>';

                // Build sample answer table
                let sampleTableHTML = `
                    <table class="grading-table grading-sample-table">
                        <thead>
                            <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
                        </thead>
                        <tbody>
                `;

                item.data.answer.forEach(row => {
                    sampleTableHTML += '<tr>';
                    if (Array.isArray(row)) {
                        row.forEach(cell => {
                            sampleTableHTML += `<td>${cell}</td>`;
                        });
                    } else {
                        sampleTableHTML += `<td colspan="${headers.length}">${row}</td>`;
                    }
                    sampleTableHTML += '</tr>';
                });

                sampleTableHTML += '</tbody></table>';

                contentHTML = `
                    <div class="grading-modal-content">
                        <div class="grading-header">
                            <h3>Grade Your Answer</h3>
                            <span class="grading-position">${index + 1} of ${gradingItems.length}</span>
                        </div>
                        <div class="grading-question">
                            <strong>Question (${item.data.points} points):</strong>
                            <p>${item.data.question}</p>
                        </div>
                        <div class="grading-your-answer">
                            <strong>Your Answer:</strong>
                            ${studentTableHTML}
                        </div>
                        <div class="grading-sample-answer">
                            <strong>Sample Answer:</strong>
                            ${sampleTableHTML}
                        </div>
                        <div class="grading-points-section">
                            <label class="grading-label">How did your answer compare?</label>
                            <div class="grading-buttons-grid" id="grading-buttons-${index}">
                                ${generateGradingButtons(item.data.points, gradingScores.get(index))}
                            </div>
                            <input type="hidden" id="grading-points-input" value="${gradingScores.get(index) || ''}">
                        </div>
                        <div class="grading-buttons">
                            <button class="grading-btn grading-prev" onclick="navigateGrading(-1)" ${index === 0 ? 'disabled' : ''}>‚Äπ Previous</button>
                            <button class="grading-btn grading-next" onclick="navigateGrading(1)">${isLastItem ? 'Finish Grading ‚Üí' : 'Next ‚Ä∫'}</button>
                        </div>
                    </div>
                `;
            }

            modal.innerHTML = contentHTML;
            document.body.appendChild(modal);

            // Add keyboard navigation
            const handleKeydown = (e) => {
                // Number keys 0-9 for quick selection
                if (e.key >= '0' && e.key <= '9') {
                    const points = parseInt(e.key);
                    const maxPoints = item.data.points;
                    if (points <= maxPoints) {
                        e.preventDefault();
                        selectGradingPoints(points);
                    }
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    // Auto-advance if a selection has been made
                    const hiddenInput = document.getElementById('grading-points-input');
                    if (hiddenInput && hiddenInput.value !== '') {
                        navigateGrading(1);
                    }
                } else if (e.key === 'ArrowLeft' && index > 0) {
                    e.preventDefault();
                    navigateGrading(-1);
                } else if (e.key === 'ArrowRight' && index < gradingItems.length - 1) {
                    e.preventDefault();
                    navigateGrading(1);
                }
            };

            document.addEventListener('keydown', handleKeydown);

            // Store cleanup function
            modal.dataset.cleanupHandler = 'keydown';
            modal.cleanupKeydown = handleKeydown;
        }

        function navigateGrading(direction) {
            // Save current score (if selected)
            const pointsInput = document.getElementById('grading-points-input');
            if (pointsInput && pointsInput.value !== '') {
                const points = parseFloat(pointsInput.value);
                gradingScores.set(currentGradingIndex, points);
            }

            // If moving forward from last item, finish grading
            if (direction > 0 && currentGradingIndex === gradingItems.length - 1) {
                finishGrading();
                return;
            }

            // Navigate to next/previous item
            const newIndex = currentGradingIndex + direction;
            if (newIndex >= 0 && newIndex < gradingItems.length) {
                // Remove old keydown listener
                const modal = document.querySelector('.grading-modal');
                if (modal && modal.cleanupKeydown) {
                    document.removeEventListener('keydown', modal.cleanupKeydown);
                }

                currentGradingIndex = newIndex;
                showGradingModalAtIndex(currentGradingIndex);
            }
        }

        function finishGrading() {
            // Remove modal and cleanup
            const modal = document.querySelector('.grading-modal');
            if (modal) {
                if (modal.cleanupKeydown) {
                    document.removeEventListener('keydown', modal.cleanupKeydown);
                }
                modal.remove();
            }

            // Show essay/table answers inline on the page
            showEssayReviewInline();

            // Calculate final score with the graded essays/tables
            autoCalculateFinalScore();
        }

        function showEssayReviewInline() {
            // Display all graded essays and tables inline on the page
            gradingItems.forEach((item, index) => {
                const points = gradingScores.get(index) || 0;

                if (item.type === 'essay') {
                    const textarea = document.querySelector(`textarea[name="essay${item.originalIndex}"]`);
                    const answerElement = document.getElementById(`essay-answer-${item.originalIndex}`);
                    const gradingElement = document.getElementById(`essay-grading-${item.originalIndex}`);

                    // Style the student's answer
                    if (textarea) {
                        textarea.readOnly = true;
                        textarea.style.minHeight = 'auto';
                        textarea.style.height = Math.max(textarea.scrollHeight, 120) + 'px';
                        textarea.style.backgroundColor = '#f8fafc';
                        textarea.style.cursor = 'default';
                    }

                    // Show sample answer
                    if (answerElement) {
                        answerElement.style.display = 'block';
                    }

                    // Show points awarded (replace input with static display)
                    if (gradingElement) {
                        gradingElement.innerHTML = `
                            <h4>Points Awarded:</h4>
                            <div class="points-awarded-display">
                                <strong>${points} / ${item.data.points}</strong> points
                            </div>
                        `;
                        gradingElement.style.display = 'block';
                    }
                } else if (item.type === 'table') {
                    const answerElement = document.getElementById(`table-answer-${item.originalIndex}`);
                    const gradingElement = document.getElementById(`table-grading-${item.originalIndex}`);

                    // Make table inputs read-only
                    const tableInputs = document.querySelectorAll(`textarea[name^="table${item.originalIndex}-"]`);
                    tableInputs.forEach(input => {
                        input.readOnly = true;
                    });

                    // Show sample answer
                    if (answerElement) {
                        answerElement.style.display = 'block';
                    }

                    // Show points awarded (replace input with static display)
                    if (gradingElement) {
                        gradingElement.innerHTML = `
                            <h4>Points Awarded:</h4>
                            <div class="points-awarded-display">
                                <strong>${points} / ${item.data.points}</strong> points
                            </div>
                        `;
                        gradingElement.style.display = 'block';
                    }
                }
            });
        }

        function autoCalculateFinalScore() {
            if (!quizData) return;

            let essayScore = 0;
            let essayMaxPoints = 0;
            let tableScore = 0;
            let tableMaxPoints = 0;

            // Calculate scores from grading modal
            gradingItems.forEach((item, index) => {
                const points = gradingScores.get(index) || 0;
                const clampedPoints = Math.min(Math.max(points, 0), item.data.points);

                if (item.type === 'essay') {
                    essayScore += clampedPoints;
                    essayMaxPoints += item.data.points;
                } else if (item.type === 'table') {
                    tableScore += clampedPoints;
                    tableMaxPoints += item.data.points;
                }
            });

            // Get existing MC and TMT scores
            const questions = selectedQuestions || [];
            const tmtQuestions = quizData.trueMakeTrue || [];

            let mcScore = 0, tmtScore = 0;

            // Recalculate MC score
            questions.forEach((question, index) => {
                const selected = document.querySelector(`input[name="q${index}"]:checked`);
                if (selected && parseInt(selected.value) === question.correct) {
                    mcScore += 2;
                }
            });

            // Recalculate TMT score
            tmtQuestions.forEach((item, index) => {
                const input = document.querySelector(`input[name="tmt${index}"]`);
                if (input) {
                    const userAnswer = input.value.trim().toLowerCase();
                    let isCorrect = false;

                    if (item.isTrue) {
                        isCorrect = userAnswer === 'true' || userAnswer === 't';
                    } else {
                        const correctWords = Array.isArray(item.correctWord) ? item.correctWord : [item.correctWord];
                        isCorrect = correctWords.some(word => userAnswer === word.toLowerCase());
                    }

                    if (isCorrect) tmtScore += (item.points || 1);
                }
            });

            // Calculate final totals
            const tmtMaxPoints = tmtQuestions.reduce((sum, item) => sum + (item.points || 1), 0);
            const totalScore = mcScore + tmtScore + tableScore + essayScore;
            const maxScore = questions.length * 2 + tmtMaxPoints + tableMaxPoints + essayMaxPoints;
            const finalPercentage = Math.round((totalScore / maxScore) * 100);

            let finalScoreDisplay = `Final Score: ${totalScore}/${maxScore} (${finalPercentage}%)`;

            // Build breakdown string
            let breakdown = `<br><small>Multiple Choice: ${mcScore}/${questions.length * 2}`;
            if (tmtMaxPoints > 0) breakdown += ` | True/Make True: ${tmtScore}/${tmtMaxPoints}`;
            if (tableMaxPoints > 0) breakdown += ` | Tables: ${tableScore}/${tableMaxPoints}`;
            if (essayMaxPoints > 0) breakdown += ` | Essays: ${essayScore}/${essayMaxPoints}`;
            breakdown += `</small>`;

            finalScoreDisplay += breakdown;

            // Update the main score display
            document.getElementById('score').innerHTML = finalScoreDisplay;
        }

        // Share exam function
        function shareExam() {
            const currentUrl = window.location.href;

            // Copy to clipboard
            navigator.clipboard.writeText(currentUrl).then(() => {
                const shareBtn = document.getElementById('share-button');
                const originalText = shareBtn.innerHTML;

                shareBtn.innerHTML = '‚úì Copied!';
                shareBtn.style.background = '#10b981';
                shareBtn.style.borderColor = '#10b981';
                shareBtn.style.color = 'white';

                setTimeout(() => {
                    shareBtn.innerHTML = originalText;
                    shareBtn.style.background = '';
                    shareBtn.style.borderColor = '';
                    shareBtn.style.color = '';
                }, 2000);
            }).catch(err => {
                alert('Failed to copy URL. Please copy manually: ' + currentUrl);
            });
        }

        // Load quiz when page loads
        document.addEventListener('DOMContentLoaded', loadQuizData);
    </script>
</body>
</html>