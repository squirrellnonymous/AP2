<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Practice Practical #3</title>

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Practice Practical #2 Part 2 - Vessels" id="og-title">
    <meta property="og:description" content="Interactive anatomy practical covering blood vessels and circulatory pathways" id="og-description">
    <meta property="og:image" content="images/practical-2-2/01.jpg" id="og-image">
    <meta property="og:url" content="unit2-part2-practical.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Practice Practical #2 Part 2 - Vessels" id="twitter-title">
    <meta name="twitter:description" content="Interactive anatomy practical covering blood vessels and circulatory pathways" id="twitter-description">
    <meta name="twitter:image" content="images/practical-2-2/01.jpg" id="twitter-image">

    <link rel="stylesheet" href="css/practical.css">
    <link rel="stylesheet" href="css/themes.css">
</head>
<body>
    <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
        <span class="toggle-icon">üåô</span>
    </button>
    <div class="header">
        <div class="header-content">
            <a href="index.html" class="home-link">‚Üê Home</a>
            <h1>Practical #3 ‚Äî Blood Vessels</h1>
            <div class="question-count"></div>
        </div>
    </div>

    <div class="container">
        <div id="loading" class="loading">
            Loading practical questions...
        </div>

        <div id="practical-content" class="practical-content" style="display: none;">
            <!-- Current image display -->
            <div class="image-container">
                <div class="image-content">
                    <img id="current-image" src="" alt="Practical question" />
                    <div id="current-question-text" class="question-text"></div>
                    <div class="inline-answer">
                        <div class="answer-center">
                            <button id="inline-question-number" class="inline-number" onclick="scrollToAnswerSheet()">1</button>
                            <input type="text" id="inline-answer-input" class="inline-input" placeholder="Type your answer..." oninput="syncAnswer()" onkeydown="handleEnterKey(event)" autocorrect="off" autocapitalize="off" spellcheck="false" />
                        </div>
                    </div>
                    <div class="navigation-buttons">
                        <button id="prev-btn" class="nav-btn nav-prev" onclick="previousImage()">‚Äπ</button>
                        <button id="next-btn" class="nav-btn nav-next" onclick="nextImage()">Next ‚Ä∫</button>
                        <button id="inline-submit-btn" class="nav-btn nav-submit" onclick="submitPractical()" style="display: none;">Submit</button>
                    </div>
                    <div class="image-counter">
                        Question <span id="current-question">1</span> of 42
                    </div>
                </div>
            </div>
        </div>

        <!-- Answer Sheet -->
        <div class="answer-sheet">
            <div class="answer-sheet-header">
                <h2>Answer Sheet</h2>
                <div class="header-controls">
                    <button class="submit-button" onclick="submitPractical()">Submit Practical</button>
                    <div id="final-score" class="final-score" style="display: none;"></div>
                </div>
            </div>
            <div class="answers-grid">
                <!-- Generated by JavaScript -->
            </div>
        </div>

    </div>

    <script>
        let practicalData = null;
        let currentImageIndex = 0;
        let preloadedImages = new Map(); // Cache for preloaded images

        // Shared answer normalizer - used for both duplicate detection and grading
        function normalizeAnswer(answer) {
            let normalized = answer.toLowerCase().trim();

            // Remove leading articles
            if (normalized.startsWith('the ')) {
                normalized = normalized.substring(4);
            } else if (normalized.startsWith('an ')) {
                normalized = normalized.substring(3);
            } else if (normalized.startsWith('a ')) {
                normalized = normalized.substring(2);
            }

            // Convert Roman numerals to Arabic numerals
            normalized = normalized.replace(/\bii\b/g, '2');
            normalized = normalized.replace(/\bi\b/g, '1');

            // Handle common plural forms
            if (normalized.endsWith('s') && normalized.length > 3 &&
                !normalized.endsWith('ss') && !normalized.endsWith('us') &&
                !normalized.endsWith('is') && !normalized.endsWith('os')) {
                normalized = normalized.slice(0, -1);
            } else if (normalized.endsWith('ies') && normalized.length > 4) {
                normalized = normalized.slice(0, -3) + 'y';
            } else if (normalized.endsWith('ves') && normalized.length > 4) {
                normalized = normalized.slice(0, -3) + 'fe';
            }

            return normalized;
        }

        // Fisher-Yates shuffle algorithm
        function shuffleArray(array) {
            const shuffled = [...array]; // Create a copy
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function removeDuplicateAnswers(imageQuestions, textOnlyQuestions) {
            const answerGroups = new Map();

            // Group all questions by their first/primary answer (normalized)
            [...imageQuestions, ...textOnlyQuestions].forEach(question => {
                if (question.answer && question.answer.length > 0) {
                    const primaryAnswer = normalizeAnswer(question.answer[0]);

                    if (!answerGroups.has(primaryAnswer)) {
                        answerGroups.set(primaryAnswer, []);
                    }
                    answerGroups.get(primaryAnswer).push(question);
                }
            });

            // From each group, pick the best representative
            const uniqueQuestions = [];
            answerGroups.forEach(group => {
                // Prefer image questions over text-only when there's a choice
                const imageQs = group.filter(q => q.image);
                const textQs = group.filter(q => !q.image);

                if (imageQs.length > 0) {
                    uniqueQuestions.push(imageQs[0]); // Take first image question
                } else if (textQs.length > 0) {
                    uniqueQuestions.push(textQs[0]); // Take first text question
                }
            });

            // Separate back into image and text-only
            return {
                imageQuestions: uniqueQuestions.filter(q => q.image),
                textOnlyQuestions: uniqueQuestions.filter(q => !q.image)
            };
        }

        function getTextOnlyThemeClass(themeName) {
            return `text-only-theme-${themeName || 'default'}`;
        }

        function avoidDissectionInEarlyPositions(selectedQuestions) {
            // Check if first two questions have dissection tag
            for (let i = 0; i < Math.min(2, selectedQuestions.length); i++) {
                const question = selectedQuestions[i];
                if (question.tags && question.tags.includes('dissection')) {
                    // Find a non-dissection question to swap with (starting from position 2)
                    for (let j = 2; j < selectedQuestions.length; j++) {
                        const swapQuestion = selectedQuestions[j];
                        if (!swapQuestion.tags || !swapQuestion.tags.includes('dissection')) {
                            // Swap them
                            [selectedQuestions[i], selectedQuestions[j]] = [selectedQuestions[j], selectedQuestions[i]];
                            break;
                        }
                    }
                }
            }
            return selectedQuestions;
        }

        function hasConflictingAnatomicalTerms(studentAnswer, correctAnswer) {
            const student = studentAnswer.toLowerCase();
            const correct = correctAnswer.toLowerCase();

            // Define conflicting pairs - if student answer contains one term but correct contains the other
            const conflictingPairs = [
                ['bicuspid', 'tricuspid'],
                ['left', 'right'],
                ['superior', 'inferior'],
                ['anterior', 'posterior'],
                ['atrial', 'ventricular'],
                ['systemic', 'pulmonary'],
                ['artery', 'vein'],
                ['ascending', 'descending']
            ];

            for (const [term1, term2] of conflictingPairs) {
                // If student used term1 but correct answer has term2, or vice versa
                if ((student.includes(term1) && correct.includes(term2)) ||
                    (student.includes(term2) && correct.includes(term1))) {
                    return true;
                }
            }

            return false;
        }

        async function loadPractical() {
            try {
                const response = await fetch('data/unit2-part2-practical.yml');
                const yamlText = await response.text();
                practicalData = jsyaml.load(yamlText);

                // Update meta tags if specified in YAML
                if (practicalData.share_image) {
                    const imageUrl = `images/${practicalData.share_image}`;
                    document.getElementById('og-image')?.setAttribute('content', imageUrl);
                    document.getElementById('twitter-image')?.setAttribute('content', imageUrl);
                }
                if (practicalData.title) {
                    document.getElementById('og-title')?.setAttribute('content', practicalData.title);
                    document.getElementById('twitter-title')?.setAttribute('content', practicalData.title);
                }
                if (practicalData.description) {
                    document.getElementById('og-description')?.setAttribute('content', practicalData.description);
                    document.getElementById('twitter-description')?.setAttribute('content', practicalData.description);
                }

                // Shuffle the questions
                if (practicalData && practicalData.questions) {
                    practicalData.questions = shuffleArray(practicalData.questions);
                }
            } catch (error) {
                console.error('Error loading YAML:', error);
                console.log('Using fallback data');
                // Fallback data structure
                practicalData = {
                    title: "Practice Practical #2 Part 2",
                    description: "Blood vessels and circulatory pathways identification practical",
                    questions: [
                        { id: 1, image: "images/practical-2/01.jpg", answer: "Sample Answer 1" },
                        { id: 2, image: "images/practical-2/02.jpg", answer: "Sample Answer 2" }
                        // Add more as needed
                    ]
                };
            }

            renderPractical();
        }

        function renderPractical() {
            if (!practicalData) return;

            // Filter out blank/placeholder questions and extra-credit questions for display
            const validQuestions = practicalData.questions.filter(question => {
                const hasQuestion = question.question && question.question.trim() !== '';
                const hasAnswer = question.answer && (
                    Array.isArray(question.answer)
                        ? question.answer.some(ans => ans && ans.trim() !== '')
                        : question.answer.trim() !== ''
                );
                const isNotExtraCredit = !question.tags || !question.tags.includes('extra-credit');
                return hasQuestion && hasAnswer && isNotExtraCredit;
            });

            // Separate image and text-only questions
            let imageQuestions = validQuestions.filter(q => q.image);
            let textOnlyQuestions = validQuestions.filter(q => !q.image);

            // Remove questions with duplicate answers
            const uniqueQuestions = removeDuplicateAnswers(imageQuestions, textOnlyQuestions);
            imageQuestions = uniqueQuestions.imageQuestions;
            textOnlyQuestions = uniqueQuestions.textOnlyQuestions;

            // Smart selection with limited and distributed text-only questions
            let selectedQuestions = [];

            if (validQuestions.length > 40) {
                // If we have plenty of questions, limit text-only to max 12.5% of total (5 out of 40)
                const maxTextOnly = Math.min(textOnlyQuestions.length, 5);
                const numImageQuestions = 40 - maxTextOnly;

                // Select questions
                const selectedImageQuestions = shuffleArray(imageQuestions).slice(0, numImageQuestions);
                const selectedTextOnlyQuestions = shuffleArray(textOnlyQuestions).slice(0, maxTextOnly);

                // Distribute text-only questions evenly throughout the practical
                selectedQuestions = [...selectedImageQuestions];
                if (selectedTextOnlyQuestions.length > 0) {
                    const spacing = Math.floor(selectedImageQuestions.length / selectedTextOnlyQuestions.length);
                    selectedTextOnlyQuestions.forEach((textQ, index) => {
                        const insertPosition = (index + 1) * spacing + index;
                        selectedQuestions.splice(Math.min(insertPosition, selectedQuestions.length), 0, textQ);
                    });
                }

                // Avoid dissection questions in the first two positions
                selectedQuestions = avoidDissectionInEarlyPositions(selectedQuestions);
            } else {
                // If we have fewer questions, just use them all but still shuffle
                selectedQuestions = shuffleArray(validQuestions);
            }

            // Update practicalData to only include selected questions
            practicalData.validQuestions = selectedQuestions;
            const totalQuestions = selectedQuestions.length;
            console.log('Valid questions:', totalQuestions);

            // Update header with correct count
            const countElement = document.querySelector('.question-count');
            if (countElement) {
                countElement.textContent = `${totalQuestions} Questions`;
            }

            // Generate answer sheet
            const answersGrid = document.querySelector('.answers-grid');
            answersGrid.innerHTML = ''; // Clear existing content

            // Create two columns
            const leftColumn = document.createElement('div');
            const rightColumn = document.createElement('div');
            leftColumn.className = 'answer-column';
            rightColumn.className = 'answer-column';

            for (let i = 1; i <= totalQuestions; i++) {
                const answerItem = document.createElement('div');
                answerItem.className = 'answer-item';
                answerItem.innerHTML = `
                    <button class="answer-number"
                            onclick="goToImage(${i - 1})"
                            tabindex="-1">${i}</button>
                    <input type="text" name="answer${i}"
                           readonly
                           onclick="goToQuestionAndFocus(${i - 1})"
                           tabindex="${i}" />
                `;

                // Distribute based on total questions
                const midpoint = Math.ceil(totalQuestions / 2);
                if (i <= midpoint) {
                    leftColumn.appendChild(answerItem);
                } else {
                    rightColumn.appendChild(answerItem);
                }
            }

            answersGrid.appendChild(leftColumn);
            answersGrid.appendChild(rightColumn);

            // Add extra credit section (randomly select only one if multiple exist)
            const allExtraCreditQuestions = practicalData.questions.filter(question => {
                const hasQuestion = question.question && question.question.trim() !== '';
                const hasAnswer = question.answer && (
                    Array.isArray(question.answer)
                        ? question.answer.some(ans => ans && ans.trim() !== '')
                        : question.answer.trim() !== ''
                );
                const isExtraCredit = question.tags && question.tags.includes('extra-credit');
                return hasQuestion && hasAnswer && isExtraCredit;
            });

            // Randomly select only one extra credit question
            const extraCreditQuestions = allExtraCreditQuestions.length > 0
                ? [allExtraCreditQuestions[Math.floor(Math.random() * allExtraCreditQuestions.length)]]
                : [];

            if (extraCreditQuestions.length > 0) {
                const extraCreditSection = document.createElement('div');
                extraCreditSection.className = 'extra-credit-section';
                extraCreditSection.innerHTML = `
                    <div class="extra-credit-header">Extra Credit</div>
                    <div class="extra-credit-questions"></div>
                `;

                const extraCreditContainer = extraCreditSection.querySelector('.extra-credit-questions');
                extraCreditQuestions.forEach((question, index) => {
                    const extraCreditItem = document.createElement('div');
                    extraCreditItem.className = 'extra-credit-item';
                    extraCreditItem.innerHTML = `
                        <button class="extra-credit-button"
                                onclick="showExtraCreditImage(${index})"
                                tabindex="-1">EC</button>
                        <input type="text" name="extra-credit-${index}"
                               class="extra-credit-input"
                               readonly
                               onclick="showExtraCreditImage(${index})"
                               tabindex="${totalQuestions + index + 1}" />
                    `;
                    extraCreditContainer.appendChild(extraCreditItem);
                });

                answersGrid.appendChild(extraCreditSection);

                // Store extra credit questions for later use
                practicalData.extraCreditQuestions = extraCreditQuestions;
            }

            // Show first image
            showImage(0);

            document.getElementById('loading').style.display = 'none';
            document.getElementById('practical-content').style.display = 'block';
        }

        function showImage(index) {
            if (!practicalData || !practicalData.validQuestions) return;

            // Reset extra credit state when viewing regular questions
            isViewingExtraCredit = false;
            currentExtraCreditIndex = -1;

            currentImageIndex = index;
            const question = practicalData.validQuestions[index];

            // Clear the current image immediately to prevent old image showing
            const imageElement = document.getElementById('current-image');
            imageElement.src = '';

            if (question) {
                if (question.image) {
                    // Image-based question
                    const imagePath = `images/${question.image}`;
                    imageElement.src = imagePath;
                    imageElement.style.display = 'block';
                    document.getElementById('current-question-text').innerHTML = question.question || '';

                    // Add click handler for full-size view on mobile
                    imageElement.onclick = () => showFullImageModal(imagePath);
                    imageElement.style.cursor = 'pointer';
                    imageElement.title = 'Click to view full size';
                } else {
                    // Text-only question - replace image with themed text box
                    imageElement.style.display = 'none';
                    imageElement.onclick = null;
                    imageElement.style.cursor = 'default';
                    imageElement.title = '';

                    // Get theme class
                    const themeClass = getTextOnlyThemeClass(question.theme);

                    document.getElementById('current-question-text').innerHTML = `
                        <div class="text-only-question-box ${themeClass}">
                            ${question.question || ''}
                        </div>&nbsp;
                    `;
                }

                // Update inline answer elements
                const inlineNumber = document.getElementById('inline-question-number');
                const inlineInput = document.getElementById('inline-answer-input');
                inlineNumber.textContent = index + 1;
                const currentAnswer = document.querySelector(`input[name="answer${index + 1}"]`);
                inlineInput.value = currentAnswer ? currentAnswer.value : '';
                inlineInput.placeholder = 'Type your answer...'; // Reset placeholder
            }

            // Update navigation buttons
            const maxIndex = practicalData.validQuestions.length - 1;
            const hasExtraCredit = practicalData && practicalData.extraCreditQuestions && practicalData.extraCreditQuestions.length > 0;

            document.getElementById('prev-btn').disabled = index === 0;
            const isLastQuestion = index >= maxIndex && !hasExtraCredit;
            document.getElementById('next-btn').disabled = isLastQuestion;

            // Keep next button visible but disabled at the last question
            const nextBtn = document.getElementById('next-btn');
            const submitBtn = document.getElementById('inline-submit-btn');
            nextBtn.style.display = 'block';
            submitBtn.style.display = 'none';

            // Clear prominent styling for regular questions
            const prevBtn = document.getElementById('prev-btn');
            prevBtn.classList.remove('prominent');
            nextBtn.classList.remove('prominent');

            // Update image counter
            const totalQuestions = practicalData.validQuestions.length;
            document.querySelector('.image-counter').innerHTML = `Question <span id="current-question">${index + 1}</span> of ${totalQuestions}`;

            // Update answer sheet number highlighting
            document.querySelectorAll('.answer-number').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });

            // Preload adjacent images
            preloadAdjacentImages(index);
        }

        function preloadImage(imagePath) {
            if (!imagePath || preloadedImages.has(imagePath)) {
                return; // Already preloaded or no path
            }

            const img = new Image();
            img.onload = () => {
                preloadedImages.set(imagePath, img);
            };
            img.src = `images/${imagePath}`;
        }

        function preloadAdjacentImages(currentIndex) {
            if (!practicalData || !practicalData.validQuestions) return;

            // Preload previous image
            if (currentIndex > 0) {
                const prevQuestion = practicalData.validQuestions[currentIndex - 1];
                if (prevQuestion && prevQuestion.image) {
                    preloadImage(prevQuestion.image);
                }
            }

            // Preload next image
            if (currentIndex < practicalData.validQuestions.length - 1) {
                const nextQuestion = practicalData.validQuestions[currentIndex + 1];
                if (nextQuestion && nextQuestion.image) {
                    preloadImage(nextQuestion.image);
                }
            }
        }

        function goToImage(index) {
            if (practicalData && practicalData.validQuestions && index >= 0 && index < practicalData.validQuestions.length) {
                showImage(index);
            }
        }

        function showExtraCreditImage(extraCreditIndex) {
            if (!practicalData || !practicalData.extraCreditQuestions) return;

            const question = practicalData.extraCreditQuestions[extraCreditIndex];
            if (!question) return;

            // Update tracking variables
            isViewingExtraCredit = true;
            currentExtraCreditIndex = extraCreditIndex;

            // Update main image or text
            const imageElement = document.getElementById('current-image');
            imageElement.src = '';

            if (question.image) {
                // Image-based extra credit question
                const imagePath = `images/${question.image}`;
                imageElement.src = imagePath;
                imageElement.style.display = 'block';
                document.getElementById('current-question-text').innerHTML = question.question || 'Extra Credit Question';

                // Add click handler for full-size view on mobile
                imageElement.onclick = () => showFullImageModal(imagePath);
                imageElement.style.cursor = 'pointer';
                imageElement.title = 'Click to view full size';
            } else {
                // Text-only extra credit question
                imageElement.style.display = 'none';
                imageElement.onclick = null;
                imageElement.style.cursor = 'default';
                imageElement.title = '';

                // Get theme class
                const themeClass = getTextOnlyThemeClass(question.theme);

                document.getElementById('current-question-text').innerHTML = `
                    <div class="text-only-question-box ${themeClass}">
                        ${question.question || 'Extra Credit Question'}
                    </div>&nbsp;
                `;
            }

            // Update image counter for extra credit
            document.querySelector('.image-counter').innerHTML = `Extra Credit Question`;

            // Clear regular answer highlighting
            document.querySelectorAll('.answer-number').forEach(btn => {
                btn.classList.remove('active');
            });

            // Highlight extra credit button
            document.querySelectorAll('.extra-credit-button').forEach((btn, i) => {
                btn.classList.toggle('active', i === extraCreditIndex);
            });

            // Update inline answer section
            const inlineNumber = document.getElementById('inline-question-number');
            const inlineInput = document.getElementById('inline-answer-input');
            if (inlineNumber && inlineInput) {
                inlineNumber.textContent = 'EC';
                inlineInput.value = document.querySelector(`input[name="extra-credit-${extraCreditIndex}"]`).value || '';
                inlineInput.placeholder = 'Extra credit answer...';
            }

            // Update navigation buttons for extra credit
            const isLastExtraCredit = extraCreditIndex >= (practicalData.extraCreditQuestions.length - 1);
            document.getElementById('prev-btn').disabled = false; // Can always go back from EC
            document.getElementById('next-btn').disabled = isLastExtraCredit; // Disable if on last EC

            // Keep next button visible but disabled for extra credit
            const nextBtn = document.getElementById('next-btn');
            const submitBtn = document.getElementById('inline-submit-btn');
            nextBtn.style.display = 'block';
            submitBtn.style.display = 'none';

            // Clear any prominent styling (removed distracting styling)
            const prevBtn = document.getElementById('prev-btn');
            prevBtn.classList.remove('prominent');
            nextBtn.classList.remove('prominent');

            // Scroll to the image container and focus the inline input
            document.querySelector('.image-container').scrollIntoView({ behavior: 'smooth' });
            setTimeout(() => {
                document.getElementById('inline-answer-input').focus();
            }, 300);
        }

        function goToQuestionAndFocus(index) {
            if (practicalData && practicalData.validQuestions && index >= 0 && index < practicalData.validQuestions.length) {
                showImage(index);
                // Scroll to the image container
                document.querySelector('.image-container').scrollIntoView({ behavior: 'smooth' });
                // Focus the inline answer input after scrolling
                setTimeout(() => {
                    document.getElementById('inline-answer-input').focus();
                }, 300);
            }
        }

        let currentExtraCreditIndex = -1; // -1 means not viewing extra credit
        let isViewingExtraCredit = false;

        function previousImage() {
            if (isViewingExtraCredit) {
                if (currentExtraCreditIndex > 0) {
                    // Previous extra credit question
                    showExtraCreditImage(currentExtraCreditIndex - 1);
                } else {
                    // Go back to last regular question
                    isViewingExtraCredit = false;
                    currentExtraCreditIndex = -1;
                    const lastRegularIndex = practicalData && practicalData.validQuestions ? practicalData.validQuestions.length - 1 : 0;
                    showImage(lastRegularIndex);
                }
            } else if (currentImageIndex > 0) {
                showImage(currentImageIndex - 1);
            }
        }

        function nextImage() {
            const maxIndex = practicalData && practicalData.validQuestions ? practicalData.validQuestions.length - 1 : 0;
            const hasExtraCredit = practicalData && practicalData.extraCreditQuestions && practicalData.extraCreditQuestions.length > 0;

            if (isViewingExtraCredit) {
                const maxExtraCreditIndex = practicalData.extraCreditQuestions.length - 1;
                if (currentExtraCreditIndex < maxExtraCreditIndex) {
                    // Next extra credit question
                    showExtraCreditImage(currentExtraCreditIndex + 1);
                }
                // If at last extra credit, stay there (no wrap around)
            } else if (currentImageIndex < maxIndex) {
                showImage(currentImageIndex + 1);
            } else if (hasExtraCredit && currentImageIndex === maxIndex) {
                // At last regular question, move to first extra credit
                showExtraCreditImage(0);
            }

            // Focus the answer input after navigation
            setTimeout(() => {
                document.getElementById('inline-answer-input').focus();
            }, 0);
        }

        function submitPractical() {
            if (!practicalData || !practicalData.questions) return;

            // Collect answers
            const answers = {};
            let blankCount = 0;
            const blankQuestions = [];

            const availableQuestions = practicalData.validQuestions.length;

            for (let i = 1; i <= availableQuestions; i++) {
                const input = document.querySelector(`input[name="answer${i}"]`);
                const answer = input ? input.value.trim() : '';
                answers[i] = answer;

                if (answer === '') {
                    blankCount++;
                    blankQuestions.push(i);
                }
            }

            // Warn about blank answers
            if (blankCount > 0) {
                const message = blankCount === 1
                    ? `You have 1 blank answer (Question ${blankQuestions[0]}). Are you sure you want to submit?`
                    : `You have ${blankCount} blank answers (Questions ${blankQuestions.slice(0, 5).join(', ')}${blankCount > 5 ? '...' : ''}). Are you sure you want to submit?`;

                if (!confirm(message)) {
                    return;
                }
            }

            // Filter out blank/placeholder questions
            const validQuestions = practicalData.questions.filter(question => {
                const hasQuestion = question.question && question.question.trim() !== '';
                const hasAnswer = question.answer && (
                    Array.isArray(question.answer)
                        ? question.answer.some(ans => ans && ans.trim() !== '')
                        : question.answer.trim() !== ''
                );
                return hasQuestion && hasAnswer;
            });

            // Score and update answer sheet
            let score = 0;
            let total = practicalData.validQuestions.length;

            practicalData.validQuestions.forEach((question, index) => {
                const questionNum = index + 1;
                const studentAnswer = answers[questionNum] || '';
                const correctAnswer = question.answer || '';
                const input = document.querySelector(`input[name="answer${questionNum}"]`);
                const circle = document.querySelectorAll('.answer-number')[index];

                // Skip blank/placeholder questions for scoring
                const hasValidQuestion = question.question && question.question.trim() !== '';
                const hasValidAnswer = question.answer && (
                    Array.isArray(question.answer)
                        ? question.answer.some(ans => ans && ans.trim() !== '')
                        : question.answer.trim() !== ''
                );

                if (!hasValidQuestion || !hasValidAnswer) {
                    // Just mark as disabled but don't score
                    if (circle) {
                        circle.classList.add('disabled');
                        if (input) {
                            const displayDiv = document.createElement('div');
                            displayDiv.className = 'answer-display disabled';
                            displayDiv.innerHTML = '<span class="placeholder-text">Placeholder</span>';
                            input.parentNode.replaceChild(displayDiv, input);
                        }
                    }
                    return; // Skip scoring for this question
                }

                // Calculate Levenshtein distance for similarity comparison
                const getLevenshteinDistance = (str1, str2) => {
                    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));

                    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
                    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;

                    for (let j = 1; j <= str2.length; j++) {
                        for (let i = 1; i <= str1.length; i++) {
                            if (str1[i - 1] === str2[j - 1]) {
                                matrix[j][i] = matrix[j - 1][i - 1];
                            } else {
                                matrix[j][i] = Math.min(
                                    matrix[j - 1][i] + 1,     // deletion
                                    matrix[j][i - 1] + 1,     // insertion
                                    matrix[j - 1][i - 1] + 1  // substitution
                                );
                            }
                        }
                    }

                    return matrix[str2.length][str1.length];
                };

                // Calculate similarity score (0-1) based on edit distance
                const getSimilarityScore = (str1, str2) => {
                    const maxLength = Math.max(str1.length, str2.length);
                    if (maxLength === 0) return 1;
                    const distance = getLevenshteinDistance(str1, str2);
                    return 1 - (distance / maxLength);
                };

                // Use shared normalizeAnswer function defined at top of file
                const normalizedStudentAnswer = normalizeAnswer(studentAnswer);

                // Determine scoring (exact match, partial credit, or incorrect)
                let answerResult = { isCorrect: false, isPartial: false, points: 0 };

                if (Array.isArray(correctAnswer)) {
                    // Handle multiple correct answers
                    for (const ans of correctAnswer) {
                        const normalizedCorrect = normalizeAnswer(ans);
                        if (normalizedStudentAnswer === normalizedCorrect) {
                            answerResult = { isCorrect: true, isPartial: false, points: 1 };
                            break;
                        } else {
                            const similarity = getSimilarityScore(normalizedStudentAnswer, normalizedCorrect);
                            // Consider it a close match if similarity is >= 0.75 (adjustable threshold)
                            // But exclude cases where student used a conflicting anatomical term
                            if (similarity >= 0.75 && similarity < 1 && !hasConflictingAnatomicalTerms(studentAnswer, ans)) {
                                answerResult = { isCorrect: false, isPartial: true, points: 0.5 };
                            }
                        }
                    }
                } else {
                    // Handle single correct answer
                    const normalizedCorrect = normalizeAnswer(correctAnswer);
                    if (normalizedStudentAnswer === normalizedCorrect) {
                        answerResult = { isCorrect: true, isPartial: false, points: 1 };
                    } else {
                        const similarity = getSimilarityScore(normalizedStudentAnswer, normalizedCorrect);
                        // But exclude cases where student used a conflicting anatomical term
                        if (similarity >= 0.75 && similarity < 1 && !hasConflictingAnatomicalTerms(studentAnswer, correctAnswer)) {
                            answerResult = { isCorrect: false, isPartial: true, points: 0.5 };
                        }
                    }
                }

                // Store grading results on the question object for later retrieval
                question.gradingResult = {
                    studentAnswer: studentAnswer,
                    resultType: answerResult.isCorrect ? 'correct' :
                               answerResult.isPartial ? 'partial' :
                               (studentAnswer && studentAnswer.trim() !== '') ? 'incorrect' : 'unanswered'
                };

                if (circle) {
                    score += answerResult.points; // Add points (0, 0.5, or 1)

                    if (answerResult.isCorrect) {
                        circle.classList.add('result-correct');
                        // Convert to display element
                        if (input) {
                            const displayDiv = document.createElement('div');
                            displayDiv.className = 'answer-display correct';
                            displayDiv.innerHTML = `<span class="student-answer">${studentAnswer}</span>`;
                            displayDiv.onclick = () => showQuestionPopup(questionNum, question.question, correctAnswer, question.image, studentAnswer, 'correct');
                            displayDiv.style.cursor = 'pointer';
                            input.parentNode.replaceChild(displayDiv, input);
                        }
                    } else if (answerResult.isPartial) {
                        circle.classList.add('result-partial');
                        // Convert to display element with partial credit indicator
                        if (input) {
                            const displayAnswer = Array.isArray(correctAnswer)
                                ? correctAnswer.join(' OR ')
                                : correctAnswer;

                            const displayDiv = document.createElement('div');
                            displayDiv.className = 'answer-display partial';
                            displayDiv.innerHTML = `<span class="student-answer">${studentAnswer}</span><span class="partial-indicator">(0.5)</span>`;
                            displayDiv.onclick = () => showQuestionPopup(questionNum, question.question, correctAnswer, question.image, studentAnswer, 'partial');
                            displayDiv.style.cursor = 'pointer';
                            displayDiv.title = 'Click to see question and correction - Partial credit for close answer';
                            input.parentNode.replaceChild(displayDiv, input);
                        }
                    } else if (studentAnswer) {
                        circle.classList.add('result-incorrect');
                        // Convert to display element with correction
                        if (input) {
                            const displayAnswer = Array.isArray(correctAnswer)
                                ? correctAnswer.join(' OR ')
                                : correctAnswer;

                            const displayDiv = document.createElement('div');
                            displayDiv.className = 'answer-display incorrect';
                            displayDiv.innerHTML = `<span class="student-answer">${studentAnswer}</span>`;
                            displayDiv.onclick = () => showQuestionPopup(questionNum, question.question, correctAnswer, question.image, studentAnswer, 'incorrect');
                            displayDiv.style.cursor = 'pointer';
                            displayDiv.title = 'Click to see question and correction';
                            input.parentNode.replaceChild(displayDiv, input);
                        }
                    } else {
                        circle.classList.add('result-unanswered');
                        // Show correct answer for unanswered
                        if (input) {
                            const displayAnswer = Array.isArray(correctAnswer)
                                ? correctAnswer.join(' OR ')
                                : correctAnswer;
                            const displayDiv = document.createElement('div');
                            displayDiv.className = 'answer-display unanswered';
                            displayDiv.innerHTML = `<span class="correct-answer">${displayAnswer}</span>`;
                            displayDiv.onclick = () => showQuestionPopup(questionNum, question.question, correctAnswer, question.image, '', 'unanswered');
                            displayDiv.style.cursor = 'pointer';
                            input.parentNode.replaceChild(displayDiv, input);
                        }
                    }
                }
            });

            // Score extra credit questions
            let extraCreditScore = 0;
            if (practicalData.extraCreditQuestions && practicalData.extraCreditQuestions.length > 0) {
                practicalData.extraCreditQuestions.forEach((question, index) => {
                    const input = document.querySelector(`input[name="extra-credit-${index}"]`);
                    const button = document.querySelectorAll('.extra-credit-button')[index];
                    const studentAnswer = input ? input.value.trim() : '';
                    const correctAnswer = question.answer || '';

                    // Calculate Levenshtein distance for similarity comparison (same function as above)
                    const getLevenshteinDistance = (str1, str2) => {
                        const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));

                        for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
                        for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;

                        for (let j = 1; j <= str2.length; j++) {
                            for (let i = 1; i <= str1.length; i++) {
                                if (str1[i - 1] === str2[j - 1]) {
                                    matrix[j][i] = matrix[j - 1][i - 1];
                                } else {
                                    matrix[j][i] = Math.min(
                                        matrix[j - 1][i] + 1,     // deletion
                                        matrix[j][i - 1] + 1,     // insertion
                                        matrix[j - 1][i - 1] + 1  // substitution
                                    );
                                }
                            }
                        }
                        return matrix[str2.length][str1.length];
                    };

                    let answerResult = { isCorrect: false, isPartial: false, points: 0 };

                    if (Array.isArray(correctAnswer)) {
                        // Multiple acceptable answers
                        for (const correct of correctAnswer) {
                            if (studentAnswer.toLowerCase() === correct.toLowerCase()) {
                                answerResult = { isCorrect: true, isPartial: false, points: 1 };
                                break;
                            } else {
                                // Check similarity (allow minor typos)
                                const distance = getLevenshteinDistance(studentAnswer.toLowerCase(), correct.toLowerCase());
                                const similarity = (correct.length - distance) / correct.length;
                                if (similarity >= 0.8 && !hasConflictingAnatomicalTerms(studentAnswer, correct)) {
                                    answerResult = { isCorrect: false, isPartial: true, points: 0.5 };
                                }
                            }
                        }
                    } else {
                        // Single correct answer
                        if (studentAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                            answerResult = { isCorrect: true, isPartial: false, points: 1 };
                        } else {
                            const distance = getLevenshteinDistance(studentAnswer.toLowerCase(), correctAnswer.toLowerCase());
                            const similarity = (correctAnswer.length - distance) / correctAnswer.length;
                            if (similarity >= 0.8 && !hasConflictingAnatomicalTerms(studentAnswer, correctAnswer)) {
                                answerResult = { isCorrect: false, isPartial: true, points: 0.5 };
                            }
                        }
                    }

                    // Store grading results on the question object for later retrieval
                    question.gradingResult = {
                        studentAnswer: studentAnswer,
                        resultType: answerResult.isCorrect ? 'correct' :
                                   answerResult.isPartial ? 'partial' :
                                   (studentAnswer && studentAnswer.trim() !== '') ? 'incorrect' : 'unanswered'
                    };

                    // Apply visual feedback to extra credit
                    if (answerResult.isCorrect) {
                        button.classList.add('result-correct');
                        if (input) {
                            const displayDiv = document.createElement('div');
                            displayDiv.className = 'answer-display correct';
                            displayDiv.innerHTML = `<span class="student-answer">${studentAnswer}</span> <span class="checkmark">‚úì</span>`;
                            displayDiv.onclick = () => showQuestionPopup('EC', question.question, correctAnswer, question.image, studentAnswer, 'correct');
                            displayDiv.style.cursor = 'pointer';
                            displayDiv.title = 'Click to see question and your answer';
                            input.parentNode.replaceChild(displayDiv, input);
                        }
                    } else if (answerResult.isPartial) {
                        button.classList.add('result-partial');
                        if (input) {
                            const displayAnswer = Array.isArray(correctAnswer)
                                ? correctAnswer.join(' OR ')
                                : correctAnswer;
                            const displayDiv = document.createElement('div');
                            displayDiv.className = 'answer-display partial';
                            displayDiv.innerHTML = `<span class="student-answer">${studentAnswer}</span> <span class="partial-credit">¬Ω</span><br><small class="correct-answer">Correct: ${displayAnswer}</small>`;
                            displayDiv.onclick = () => showQuestionPopup('EC', question.question, correctAnswer, question.image, studentAnswer, 'partial');
                            displayDiv.style.cursor = 'pointer';
                            displayDiv.title = 'Click to see question and correction';
                            input.parentNode.replaceChild(displayDiv, input);
                        }
                    } else if (studentAnswer) {
                        button.classList.add('result-incorrect');
                        if (input) {
                            const displayAnswer = Array.isArray(correctAnswer)
                                ? correctAnswer.join(' OR ')
                                : correctAnswer;
                            const displayDiv = document.createElement('div');
                            displayDiv.className = 'answer-display incorrect';
                            displayDiv.innerHTML = `<span class="student-answer incorrect">${studentAnswer}</span> <span class="cross">‚úó</span><br><small class="correct-answer">Correct: ${displayAnswer}</small>`;
                            displayDiv.onclick = () => showQuestionPopup('EC', question.question, correctAnswer, question.image, studentAnswer, 'incorrect');
                            displayDiv.style.cursor = 'pointer';
                            displayDiv.title = 'Click to see question and correction';
                            input.parentNode.replaceChild(displayDiv, input);
                        }
                    } else {
                        button.classList.add('result-unanswered');
                        if (input) {
                            const displayAnswer = Array.isArray(correctAnswer)
                                ? correctAnswer.join(' OR ')
                                : correctAnswer;
                            const displayDiv = document.createElement('div');
                            displayDiv.className = 'answer-display unanswered';
                            displayDiv.innerHTML = `<span class="correct-answer">${displayAnswer}</span>`;
                            displayDiv.onclick = () => showQuestionPopup('EC', question.question, correctAnswer, question.image, '', 'unanswered');
                            displayDiv.style.cursor = 'pointer';
                            input.parentNode.replaceChild(displayDiv, input);
                        }
                    }

                    // Add extra credit points (worth 2 points instead of 1)
                    if (answerResult.isCorrect) {
                        extraCreditScore += 2; // Full extra credit
                    } else if (answerResult.isPartial) {
                        extraCreditScore += 1; // Partial extra credit
                    }
                });
            }

            const totalWithEC = score + extraCreditScore;
            const totalPercentage = total > 0 ? Math.round((totalWithEC / total) * 100) : 0;
            const basePercentage = total > 0 ? Math.round((score / total) * 100) : 0;

            // Clear all answer sheet highlighting
            document.querySelectorAll('.answer-number').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.extra-credit-button').forEach(btn => {
                btn.classList.remove('active');
            });

            document.getElementById('final-score').innerHTML = extraCreditScore > 0
                ? `<strong>Final Score: ${score}+${extraCreditScore}/${total} (${totalPercentage}%)</strong>`
                : `<strong>Final Score: ${score}/${total} (${basePercentage}%)</strong>`;
            document.getElementById('final-score').style.display = 'block';
            document.querySelector('.submit-button').style.display = 'none';
        }

        function syncAnswer() {
            const inlineInput = document.getElementById('inline-answer-input');

            if (isViewingExtraCredit) {
                // Sync with extra credit input
                const extraCreditInput = document.querySelector(`input[name="extra-credit-${currentExtraCreditIndex}"]`);
                if (extraCreditInput) {
                    extraCreditInput.value = inlineInput.value;
                }
            } else {
                // Sync with regular answer input
                const currentQuestionNum = currentImageIndex + 1;
                const answerSheetInput = document.querySelector(`input[name="answer${currentQuestionNum}"]`);
                if (answerSheetInput) {
                    answerSheetInput.value = inlineInput.value;
                }
            }
        }

        function scrollToAnswerSheet() {
            document.querySelector('.answer-sheet').scrollIntoView({ behavior: 'smooth' });
        }

        function handleEnterKey(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent form submission
                nextImage(); // Move to next question
            }
        }

        function showFullImageModal(imagePath) {
            // Remove any existing modal
            const existingModal = document.querySelector('.full-image-modal');
            if (existingModal) {
                existingModal.remove();
            }

            // Create full image modal
            const modal = document.createElement('div');
            modal.className = 'full-image-modal';
            modal.innerHTML = `
                <div class="full-image-content">
                    <div class="full-image-header">
                        <button class="close-modal" onclick="this.parentElement.parentElement.parentElement.remove()">√ó</button>
                    </div>
                    <div class="full-image-container">
                        <img src="${imagePath}" alt="Full size image" class="full-size-image" />
                    </div>
                </div>
            `;

            // Add to page
            document.body.appendChild(modal);

            // Add click outside to close
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        let currentModalIndex = 0;
        let modalQuestions = [];

        function buildModalQuestionsList() {
            modalQuestions = [];

            // Add regular questions
            if (practicalData && practicalData.validQuestions) {
                practicalData.validQuestions.forEach((question, index) => {
                    modalQuestions.push({
                        type: 'regular',
                        index: index,
                        questionNum: index + 1,
                        question: question,
                        questionText: question.question || 'What is the tissue/structure?',
                        imagePath: question.image
                    });
                });
            }

            // Add extra credit questions
            if (practicalData && practicalData.extraCreditQuestions) {
                practicalData.extraCreditQuestions.forEach((question, index) => {
                    modalQuestions.push({
                        type: 'extra-credit',
                        index: index,
                        questionNum: 'EC',
                        question: question,
                        questionText: question.question || 'Extra Credit Question',
                        imagePath: question.image
                    });
                });
            }
        }

        function getQuestionData(modalQuestion) {
            let studentAnswer = '';
            let resultType = '';
            let correctAnswer = modalQuestion.question.answer;

            // Use stored grading results if available (after submission)
            if (modalQuestion.question.gradingResult) {
                studentAnswer = modalQuestion.question.gradingResult.studentAnswer;
                resultType = modalQuestion.question.gradingResult.resultType;
            } else {
                // Fallback to DOM parsing (before submission)
                if (modalQuestion.type === 'regular') {
                    const answerInput = document.querySelector(`input[name="answer${modalQuestion.questionNum}"]`);
                    if (answerInput) {
                        studentAnswer = answerInput.value.trim();
                    }
                } else {
                    // Extra credit
                    const extraCreditInput = document.querySelector(`input[name="extra-credit-${modalQuestion.index}"]`);
                    if (extraCreditInput) {
                        studentAnswer = extraCreditInput.value.trim();
                    }
                }
            }

            return { studentAnswer, resultType, correctAnswer };
        }

        function showQuestionPopup(questionNum, questionText, correctAnswer, imagePath, studentAnswer = '', resultType = '') {
            // Build the questions list if not already built
            if (modalQuestions.length === 0) {
                buildModalQuestionsList();
            }

            // Find the index in our modal questions list
            let targetIndex = 0;
            if (questionNum === 'EC') {
                // Find the extra credit question
                targetIndex = modalQuestions.findIndex(q => q.type === 'extra-credit');
            } else {
                // Find the regular question
                targetIndex = modalQuestions.findIndex(q => q.type === 'regular' && q.questionNum == questionNum);
            }

            if (targetIndex >= 0) {
                currentModalIndex = targetIndex;
            }

            showModalAtIndex(currentModalIndex);
        }

        function showModalAtIndex(index) {
            if (index < 0 || index >= modalQuestions.length) return;

            // Remove any existing popup
            const existingPopup = document.querySelector('.question-popup');
            if (existingPopup) {
                existingPopup.remove();
            }

            const modalQuestion = modalQuestions[index];
            const { studentAnswer, resultType, correctAnswer } = getQuestionData(modalQuestion);

            // Format correct answer for display
            const displayCorrectAnswer = Array.isArray(correctAnswer)
                ? correctAnswer.join(' OR ')
                : correctAnswer;

            // Create student response section based on result type
            let studentResponseSection = '';
            if (studentAnswer || resultType === 'unanswered') {
                let responseClass = '';
                let responseLabel = '';
                let responseIcon = '';

                switch (resultType) {
                    case 'correct':
                        responseClass = 'student-response-correct';
                        responseLabel = 'Your answer';
                        responseIcon = '‚úì';
                        break;
                    case 'partial':
                        responseClass = 'student-response-partial';
                        responseLabel = 'Your answer';
                        responseIcon = '¬Ω';
                        break;
                    case 'incorrect':
                        responseClass = 'student-response-incorrect';
                        responseLabel = 'Your answer';
                        responseIcon = '‚úó';
                        break;
                    case 'unanswered':
                        responseClass = 'student-response-unanswered';
                        responseLabel = 'Your answer';
                        responseIcon = '‚Äî';
                        break;
                }

                const displayStudentAnswer = (resultType === 'unanswered' || !studentAnswer) ? '(blank)' : studentAnswer;

                studentResponseSection = `
                    <div class="popup-student-response ${responseClass}">
                        <div class="response-number">${modalQuestion.questionNum}</div>
                        <span class="response-text">${displayStudentAnswer}</span>
                        <span class="response-icon">${responseIcon}</span>
                    </div>
                `;
            }

            // Show correct answer for wrong, partial, or unanswered
            let correctAnswerSection = '';
            if (resultType !== 'correct' && correctAnswer) {
                correctAnswerSection = `
                    <div class="popup-correction">
                        <span class="correction-text">${displayCorrectAnswer}</span>
                    </div>
                `;
            }

            // Navigation arrows
            const navigationSection = `
                <div class="modal-navigation">
                    <button class="modal-nav-btn modal-prev" onclick="navigateModal(-1)" ${index === 0 ? 'disabled' : ''}>‚Äπ</button>
                    <span class="modal-position">${index + 1} of ${modalQuestions.length}</span>
                    <button class="modal-nav-btn modal-next" onclick="navigateModal(1)" ${index === modalQuestions.length - 1 ? 'disabled' : ''}>‚Ä∫</button>
                </div>
            `;

            // Create popup
            const popup = document.createElement('div');
            popup.className = 'question-popup';

            // For text-only questions, apply theme styling
            let questionDisplaySection = '';
            if (modalQuestion.imagePath) {
                questionDisplaySection = `
                    <div class="popup-image">
                        <img src="images/${modalQuestion.imagePath}" alt="Question ${modalQuestion.questionNum} image" />
                    </div>
                    <div class="popup-question">${modalQuestion.questionText}</div>
                `;
            } else {
                // Text-only question - apply theme
                const themeClass = getTextOnlyThemeClass(modalQuestion.question.theme);
                questionDisplaySection = `
                    <div class="popup-question">
                        <div class="text-only-question-box ${themeClass}">
                            ${modalQuestion.questionText}
                        </div>
                    </div>
                `;
            }

            popup.innerHTML = `
                <div class="popup-content">
                    <div class="popup-header">
                        <h3>Question ${modalQuestion.questionNum}</h3>
                        <button class="close-popup" onclick="this.parentElement.parentElement.parentElement.remove()">√ó</button>
                    </div>
                    ${questionDisplaySection}
                    ${studentResponseSection}
                    ${correctAnswerSection}
                    ${navigationSection}
                </div>
            `;

            // Add to page
            document.body.appendChild(popup);

            // Add click outside to close
            popup.addEventListener('click', (e) => {
                if (e.target === popup) {
                    popup.remove();
                }
            });

            // Add keyboard navigation
            const handleKeydown = (e) => {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    navigateModal(-1);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    navigateModal(1);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    popup.remove();
                    document.removeEventListener('keydown', handleKeydown);
                }
            };

            document.addEventListener('keydown', handleKeydown);

            // Remove event listener when popup is closed
            const originalRemove = popup.remove.bind(popup);
            popup.remove = () => {
                document.removeEventListener('keydown', handleKeydown);
                originalRemove();
            };
        }

        function navigateModal(direction) {
            const newIndex = currentModalIndex + direction;
            if (newIndex >= 0 && newIndex < modalQuestions.length) {
                currentModalIndex = newIndex;
                showModalAtIndex(currentModalIndex);
            }
        }

        function toggleQuestionDetail(questionNum) {
            const existingDetail = document.getElementById(`detail-${questionNum}`);
            if (existingDetail) {
                existingDetail.remove();
                return;
            }

            // Remove any other open details
            document.querySelectorAll('[id^="detail-"]').forEach(el => el.remove());

            if (!practicalData || !practicalData.questions) return;

            const question = practicalData.questions[questionNum - 1];
            if (!question) return;

            const detailDiv = document.createElement('div');
            detailDiv.id = `detail-${questionNum}`;
            detailDiv.className = 'question-detail';
            detailDiv.innerHTML = `
                <div class="detail-content">
                    <div class="detail-image">
                        <img src="images/${question.image}" alt="Question ${questionNum}" />
                    </div>
                    <div class="detail-info">
                        <strong>Question ${questionNum}:</strong> ${question.question || 'What is the tissue/structure?'}
                    </div>
                </div>
            `;

            // Insert after the results circles
            const resultsCircles = document.querySelector('.results-circles');
            resultsCircles.insertAdjacentElement('afterend', detailDiv);
        }

        // Smart arrow key navigation
        document.addEventListener('keydown', function(event) {
            // Only handle arrow keys
            if (event.key !== 'ArrowLeft' && event.key !== 'ArrowRight') {
                return;
            }

            const inlineInput = document.getElementById('inline-answer-input');
            const isInputFocused = document.activeElement === inlineInput;

            let shouldNavigate = false;

            if (!isInputFocused) {
                // Input not focused - always allow navigation
                shouldNavigate = true;
            } else {
                // Input is focused - check cursor position
                const cursorPosition = inlineInput.selectionStart;
                const textLength = inlineInput.value.length;

                if (event.key === 'ArrowLeft' && cursorPosition === 0) {
                    // At beginning of text, allow left navigation
                    shouldNavigate = true;
                } else if (event.key === 'ArrowRight' && cursorPosition === textLength) {
                    // At end of text, allow right navigation
                    shouldNavigate = true;
                }
            }

            if (shouldNavigate) {
                event.preventDefault(); // Prevent default arrow behavior

                if (event.key === 'ArrowLeft') {
                    previousImage();
                } else if (event.key === 'ArrowRight') {
                    nextImage();
                }

                // Focus the input after navigation if it was focused before
                if (isInputFocused) {
                    setTimeout(() => {
                        document.getElementById('inline-answer-input').focus();
                    }, 0);
                }
            }
        });

        // Dark mode functionality
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const toggleIcon = document.querySelector('.toggle-icon');
        const body = document.body;

        // Function to get preferred theme
        function getPreferredTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            // Check system preference
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        // Function to apply theme
        function applyTheme(theme) {
            if (theme === 'dark') {
                body.classList.add('dark-mode');
                toggleIcon.textContent = '‚òÄÔ∏è';
            } else {
                body.classList.remove('dark-mode');
                toggleIcon.textContent = 'üåô';
            }
        }

        // Apply initial theme
        const currentTheme = getPreferredTheme();
        applyTheme(currentTheme);

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            // Only auto-switch if user hasn't set a preference
            if (!localStorage.getItem('theme')) {
                applyTheme(e.matches ? 'dark' : 'light');
            }
        });

        // Toggle dark mode
        darkModeToggle.addEventListener('click', () => {
            const newTheme = body.classList.contains('dark-mode') ? 'light' : 'dark';
            applyTheme(newTheme);
            localStorage.setItem('theme', newTheme);
        });

        // Load YAML parser
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js';
        script.onload = loadPractical;
        document.head.appendChild(script);
    </script>
</body>
</html>