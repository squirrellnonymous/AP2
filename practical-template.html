<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Practice Practical</title>

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Practice Practical" id="og-title">
    <meta property="og:description" content="Interactive anatomy practical" id="og-description">
    <meta property="og:image" content="" id="og-image">
    <meta property="og:url" content="">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Practice Practical" id="twitter-title">
    <meta name="twitter:description" content="Interactive anatomy practical" id="twitter-description">
    <meta name="twitter:image" content="" id="twitter-image">

    <link rel="stylesheet" href="css/practical.css">
    <link rel="stylesheet" href="css/themes.css">
</head>
<body>
    <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
        <span class="toggle-icon">üåô</span>
    </button>
    <div class="header">
        <div class="header-content">
            <a href="index.html" class="home-link">‚Üê Home</a>
            <h1 id="page-title">Practice Practical</h1>
            <div class="question-count"></div>
        </div>
    </div>

    <div class="container">
        <div id="loading" class="loading">
            Loading practical questions...
        </div>

        <div id="practical-content" class="practical-content" style="display: none;">
            <!-- Current image display -->
            <div class="image-container">
                <div class="image-content">
                    <img id="current-image" src="" alt="Practical question" />
                    <div id="current-question-text" class="question-text"></div>
                    <div class="inline-answer">
                        <div class="answer-center">
                            <button id="inline-question-number" class="inline-number" onclick="scrollToAnswerSheet()">1</button>
                            <input type="text" id="inline-answer-input" class="inline-input" placeholder="Type your answer..." oninput="syncAnswer()" onkeydown="handleEnterKey(event)" autocorrect="off" autocapitalize="off" spellcheck="false" />
                        </div>
                    </div>
                    <div class="navigation-buttons">
                        <button id="prev-btn" class="nav-btn nav-prev" onclick="previousImage()">‚Äπ</button>
                        <button id="next-btn" class="nav-btn nav-next" onclick="nextImage()">Next ‚Ä∫</button>
                        <button id="inline-submit-btn" class="nav-btn nav-submit" onclick="submitPractical()" style="display: none;">Submit</button>
                    </div>
                    <div class="image-counter">
                        Question <span id="current-question">1</span> of 42
                    </div>
                </div>
            </div>
        </div>

        <!-- Answer Sheet -->
        <div class="answer-sheet">
            <div class="answer-sheet-header">
                <h2>Answer Sheet</h2>
                <div class="header-controls">
                    <button class="submit-button" onclick="submitPractical()">Submit Practical</button>
                    <div id="final-score" class="final-score" style="display: none;"></div>
                </div>
            </div>
            <div class="answers-grid">
                <!-- Generated by JavaScript -->
            </div>
        </div>

    </div>

    <script>
        let practicalData = null;
        let currentImageIndex = 0;
        let preloadedImages = new Map(); // Cache for preloaded images

        // Shared functions (normalizeAnswer, shuffleArray, etc.) are now provided by:
        // - js/answer-checker.js
        // - js/question-renderer.js

        function removeDuplicateAnswers(imageQuestions, textOnlyQuestions) {
            const answerGroups = new Map();

            // Group all questions by their first/primary answer (normalized)
            [...imageQuestions, ...textOnlyQuestions].forEach(question => {
                if (question.answer && question.answer.length > 0) {
                    const primaryAnswer = normalizeAnswer(question.answer[0]);

                    if (!answerGroups.has(primaryAnswer)) {
                        answerGroups.set(primaryAnswer, []);
                    }
                    answerGroups.get(primaryAnswer).push(question);
                }
            });

            // From each group, pick a random representative
            const uniqueQuestions = [];
            answerGroups.forEach(group => {
                // Prefer image questions over text-only when there's a choice
                const imageQs = group.filter(q => q.image);
                const textQs = group.filter(q => !q.image);

                if (imageQs.length > 0) {
                    // Randomly select one image question from this group
                    const randomIndex = Math.floor(Math.random() * imageQs.length);
                    uniqueQuestions.push(imageQs[randomIndex]);
                } else if (textQs.length > 0) {
                    // Randomly select one text question from this group
                    const randomIndex = Math.floor(Math.random() * textQs.length);
                    uniqueQuestions.push(textQs[randomIndex]);
                }
            });

            // Separate back into image and text-only
            return {
                imageQuestions: uniqueQuestions.filter(q => q.image),
                textOnlyQuestions: uniqueQuestions.filter(q => !q.image)
            };
        }

        // getTextOnlyThemeClass is now provided by js/question-renderer.js

        function avoidDissectionInEarlyPositions(selectedQuestions) {
            // Check if first two questions have dissection tag
            for (let i = 0; i < Math.min(2, selectedQuestions.length); i++) {
                const question = selectedQuestions[i];
                if (question.tags && question.tags.includes('dissection')) {
                    // Find a non-dissection question to swap with (starting from position 2)
                    for (let j = 2; j < selectedQuestions.length; j++) {
                        const swapQuestion = selectedQuestions[j];
                        if (!swapQuestion.tags || !swapQuestion.tags.includes('dissection')) {
                            // Swap them
                            [selectedQuestions[i], selectedQuestions[j]] = [selectedQuestions[j], selectedQuestions[i]];
                            break;
                        }
                    }
                }
            }
            return selectedQuestions;
        }

        function balanceTagPairs(selectedQuestions, allValidQuestions, tagPairs) {
            // Process each tag pair
            tagPairs.forEach(([tag1, tag2]) => {
                // Count questions with each tag in the pair
                const tag1Questions = selectedQuestions.filter(q => q.tags && q.tags.includes(tag1));
                const tag2Questions = selectedQuestions.filter(q => q.tags && q.tags.includes(tag2));

                const tag1Count = tag1Questions.length;
                const tag2Count = tag2Questions.length;

                console.log(`Tag balance before: ${tag1}=${tag1Count}, ${tag2}=${tag2Count}`);

                // If already balanced (difference of 1 or less), no action needed
                if (Math.abs(tag1Count - tag2Count) <= 1) {
                    console.log('Already balanced!');
                    return;
                }

                // Determine which tag is overrepresented and which is underrepresented
                const overTag = tag1Count > tag2Count ? tag1 : tag2;
                const underTag = tag1Count > tag2Count ? tag2 : tag1;
                const overCount = Math.max(tag1Count, tag2Count);
                const underCount = Math.min(tag1Count, tag2Count);

                // Calculate target count (roughly 50/50, allowing ¬±1)
                const targetCount = Math.floor((overCount + underCount) / 2);
                const swapsNeeded = overCount - targetCount;

                console.log(`Need to swap ${swapsNeeded} ${overTag} questions for ${underTag} questions`);

                // Get questions NOT in selectedQuestions but available in allValidQuestions
                const availableQuestions = allValidQuestions.filter(q =>
                    !selectedQuestions.includes(q) && q.tags && q.tags.includes(underTag)
                );

                // Perform swaps
                let swapsPerformed = 0;
                for (let i = selectedQuestions.length - 1; i >= 0 && swapsPerformed < swapsNeeded && availableQuestions.length > 0; i--) {
                    const question = selectedQuestions[i];

                    // Check if this question has the overrepresented tag (and not the underrepresented tag)
                    if (question.tags && question.tags.includes(overTag) && !question.tags.includes(underTag)) {
                        // Randomly select a replacement from available questions
                        const randomIndex = Math.floor(Math.random() * availableQuestions.length);
                        const replacement = availableQuestions[randomIndex];

                        // Swap
                        selectedQuestions[i] = replacement;
                        availableQuestions.splice(randomIndex, 1);
                        swapsPerformed++;

                        console.log(`Swapped question ${question.id} (${overTag}) for ${replacement.id} (${underTag})`);
                    }
                }

                // Recount after balancing
                const finalTag1Count = selectedQuestions.filter(q => q.tags && q.tags.includes(tag1)).length;
                const finalTag2Count = selectedQuestions.filter(q => q.tags && q.tags.includes(tag2)).length;
                console.log(`Tag balance after: ${tag1}=${finalTag1Count}, ${tag2}=${finalTag2Count}`);
            });

            return selectedQuestions;
        }

        // hasConflictingAnatomicalTerms is now provided by js/answer-checker.js

        async function loadPractical() {
            try {
                // Get unit from URL parameter, default to unit3-practical4
                const urlParams = new URLSearchParams(window.location.search);
                const unit = urlParams.get('unit') || 'unit3-practical4';
                const response = await fetch(`data/${unit}.yml`);
                const yamlText = await response.text();
                practicalData = jsyaml.load(yamlText);

                // Update page title and header if specified in YAML
                if (practicalData.title) {
                    document.title = practicalData.title;
                    document.getElementById('page-title').textContent = practicalData.title;
                    document.getElementById('og-title')?.setAttribute('content', practicalData.title);
                    document.getElementById('twitter-title')?.setAttribute('content', practicalData.title);
                }

                // Update meta tags if specified in YAML
                if (practicalData.share_image) {
                    const imageUrl = `images/${practicalData.share_image}`;
                    document.getElementById('og-image')?.setAttribute('content', imageUrl);
                    document.getElementById('twitter-image')?.setAttribute('content', imageUrl);
                }
                if (practicalData.description) {
                    document.getElementById('og-description')?.setAttribute('content', practicalData.description);
                    document.getElementById('twitter-description')?.setAttribute('content', practicalData.description);
                }

                // Shuffle the questions
                if (practicalData && practicalData.questions) {
                    practicalData.questions = shuffleArray(practicalData.questions);
                }
            } catch (error) {
                console.error('Error loading YAML:', error);
                console.log('Using fallback data');
                // Fallback data structure
                practicalData = {
                    title: "Practice Practical",
                    description: "Interactive anatomy practical",
                    questions: [
                        { id: 1, image: "practical/01.jpg", answer: "Sample Answer 1" },
                        { id: 2, image: "practical/02.jpg", answer: "Sample Answer 2" }
                        // Add more as needed
                    ]
                };
            }

            renderPractical();
        }

        function renderPractical() {
            if (!practicalData) return;

            // Filter out blank/placeholder questions, extra-credit questions, and flashcard questions for display
            const validQuestions = filterValidQuestions(practicalData.questions);

            // Separate image and text-only questions
            let imageQuestions = validQuestions.filter(q => q.image);
            let textOnlyQuestions = validQuestions.filter(q => !q.image);

            // Remove questions with duplicate answers (unless disabled in config)
            if (!practicalData.allow_duplicate_answers) {
                const uniqueQuestions = removeDuplicateAnswers(imageQuestions, textOnlyQuestions);
                imageQuestions = uniqueQuestions.imageQuestions;
                textOnlyQuestions = uniqueQuestions.textOnlyQuestions;
            }

            // Smart selection with limited and distributed text-only questions
            let selectedQuestions = [];

            if (validQuestions.length > 40) {
                // Target 40 questions total, with text-only limited to max 12.5% (5 out of 40)
                const targetTotal = 40;
                const maxTextOnly = Math.min(textOnlyQuestions.length, 5);

                // Calculate how many image questions we can get
                const availableImageQuestions = imageQuestions.length;
                const targetImageQuestions = targetTotal - maxTextOnly;

                // If we don't have enough image questions to reach target, use all images and fill with text
                let selectedImageQuestions, selectedTextOnlyQuestions;

                if (availableImageQuestions >= targetImageQuestions) {
                    // We have enough image questions
                    selectedImageQuestions = shuffleArray(imageQuestions).slice(0, targetImageQuestions);
                    selectedTextOnlyQuestions = shuffleArray(textOnlyQuestions).slice(0, maxTextOnly);
                } else {
                    // Not enough image questions, use all and fill remaining with text
                    selectedImageQuestions = shuffleArray(imageQuestions);
                    const remainingSlots = targetTotal - availableImageQuestions;
                    selectedTextOnlyQuestions = shuffleArray(textOnlyQuestions).slice(0, remainingSlots);
                }

                // Distribute text-only questions evenly throughout the practical
                selectedQuestions = [...selectedImageQuestions];
                if (selectedTextOnlyQuestions.length > 0) {
                    const spacing = Math.floor(selectedImageQuestions.length / selectedTextOnlyQuestions.length);
                    selectedTextOnlyQuestions.forEach((textQ, index) => {
                        const insertPosition = (index + 1) * spacing + index;
                        selectedQuestions.splice(Math.min(insertPosition, selectedQuestions.length), 0, textQ);
                    });
                }

                // Avoid dissection questions in the first two positions
                selectedQuestions = avoidDissectionInEarlyPositions(selectedQuestions);
            } else {
                // If we have fewer questions, just use them all but still shuffle
                selectedQuestions = shuffleArray(validQuestions);
            }

            // Apply tag balancing if enabled
            if (practicalData.balance_tags && practicalData.balanced_tag_pairs) {
                selectedQuestions = balanceTagPairs(selectedQuestions, validQuestions, practicalData.balanced_tag_pairs);
            }

            // Update practicalData to only include selected questions
            practicalData.validQuestions = selectedQuestions;
            const totalQuestions = selectedQuestions.length;
            console.log('Valid questions:', totalQuestions);

            // Update header with correct count
            const countElement = document.querySelector('.question-count');
            if (countElement) {
                countElement.textContent = `${totalQuestions} Questions`;
            }

            // Generate answer sheet
            const answersGrid = document.querySelector('.answers-grid');
            answersGrid.innerHTML = ''; // Clear existing content

            // Create two columns
            const leftColumn = document.createElement('div');
            const rightColumn = document.createElement('div');
            leftColumn.className = 'answer-column';
            rightColumn.className = 'answer-column';

            for (let i = 1; i <= totalQuestions; i++) {
                const answerItem = document.createElement('div');
                answerItem.className = 'answer-item';
                answerItem.innerHTML = `
                    <button class="answer-number"
                            onclick="goToImage(${i - 1})"
                            tabindex="-1">${i}</button>
                    <input type="text" name="answer${i}"
                           readonly
                           onclick="goToQuestionAndFocus(${i - 1})"
                           tabindex="${i}" />
                `;

                // Distribute based on total questions
                const midpoint = Math.ceil(totalQuestions / 2);
                if (i <= midpoint) {
                    leftColumn.appendChild(answerItem);
                } else {
                    rightColumn.appendChild(answerItem);
                }
            }

            answersGrid.appendChild(leftColumn);
            answersGrid.appendChild(rightColumn);

            // Add extra credit section (randomly select only one if multiple exist)
            const allExtraCreditQuestions = practicalData.questions.filter(question => {
                const hasQuestion = question.question && question.question.trim() !== '';
                const hasAnswer = question.answer && (
                    Array.isArray(question.answer)
                        ? question.answer.some(ans => ans && ans.trim() !== '')
                        : question.answer.trim() !== ''
                );
                const isExtraCredit = question.tags && question.tags.includes('extra-credit');
                return hasQuestion && hasAnswer && isExtraCredit;
            });

            // Randomly select only one extra credit question
            const extraCreditQuestions = allExtraCreditQuestions.length > 0
                ? [allExtraCreditQuestions[Math.floor(Math.random() * allExtraCreditQuestions.length)]]
                : [];

            if (extraCreditQuestions.length > 0) {
                const extraCreditSection = document.createElement('div');
                extraCreditSection.className = 'extra-credit-section';
                extraCreditSection.innerHTML = `
                    <div class="extra-credit-header">Extra Credit</div>
                    <div class="extra-credit-questions"></div>
                `;

                const extraCreditContainer = extraCreditSection.querySelector('.extra-credit-questions');
                extraCreditQuestions.forEach((question, index) => {
                    const extraCreditItem = document.createElement('div');
                    extraCreditItem.className = 'extra-credit-item';
                    extraCreditItem.innerHTML = `
                        <button class="extra-credit-button"
                                onclick="showExtraCreditImage(${index})"
                                tabindex="-1">EC</button>
                        <input type="text" name="extra-credit-${index}"
                               class="extra-credit-input"
                               readonly
                               onclick="showExtraCreditImage(${index})"
                               tabindex="${totalQuestions + index + 1}" />
                    `;
                    extraCreditContainer.appendChild(extraCreditItem);
                });

                answersGrid.appendChild(extraCreditSection);

                // Store extra credit questions for later use
                practicalData.extraCreditQuestions = extraCreditQuestions;
                window.extraCreditQuestions = extraCreditQuestions;
            }

            // Show first image
            showImage(0);

            document.getElementById('loading').style.display = 'none';
            document.getElementById('practical-content').style.display = 'block';
        }

        function showImage(index) {
            if (!practicalData || !practicalData.validQuestions) return;

            // Reset extra credit state when viewing regular questions
            isViewingExtraCredit = false;
            currentExtraCreditIndex = -1;

            currentImageIndex = index;
            const question = practicalData.validQuestions[index];

            // Clear the current image immediately to prevent old image showing
            const imageElement = document.getElementById('current-image');
            imageElement.src = '';

            if (question) {
                if (question.image) {
                    // Image-based question
                    const imagePath = `images/${question.image}`;
                    imageElement.src = imagePath;
                    imageElement.style.display = 'block';
                    document.getElementById('current-question-text').innerHTML = question.question || '';

                    // Add click handler for full-size view on mobile
                    imageElement.onclick = () => showFullImageModal(imagePath);
                    imageElement.style.cursor = 'pointer';
                    imageElement.title = 'Click to view full size';
                } else {
                    // Text-only question - replace image with themed text box
                    imageElement.style.display = 'none';
                    imageElement.onclick = null;
                    imageElement.style.cursor = 'default';
                    imageElement.title = '';

                    // Get theme class
                    const themeClass = getTextOnlyThemeClass(question.theme);

                    document.getElementById('current-question-text').innerHTML = `
                        <div class="text-only-question-box ${themeClass}">
                            ${question.question || ''}
                        </div>&nbsp;
                    `;
                }

                // Update inline answer elements
                const inlineNumber = document.getElementById('inline-question-number');
                const inlineInput = document.getElementById('inline-answer-input');
                inlineNumber.textContent = index + 1;
                const currentAnswer = document.querySelector(`input[name="answer${index + 1}"]`);
                inlineInput.value = currentAnswer ? currentAnswer.value : '';
                inlineInput.placeholder = 'Type your answer...'; // Reset placeholder
            }

            // Update navigation buttons
            const maxIndex = practicalData.validQuestions.length - 1;
            const hasExtraCredit = practicalData && practicalData.extraCreditQuestions && practicalData.extraCreditQuestions.length > 0;

            document.getElementById('prev-btn').disabled = index === 0;
            const isLastQuestion = index >= maxIndex && !hasExtraCredit;
            document.getElementById('next-btn').disabled = isLastQuestion;

            // Keep next button visible but disabled at the last question
            const nextBtn = document.getElementById('next-btn');
            const submitBtn = document.getElementById('inline-submit-btn');
            nextBtn.style.display = 'block';
            submitBtn.style.display = 'none';

            // Clear prominent styling for regular questions
            const prevBtn = document.getElementById('prev-btn');
            prevBtn.classList.remove('prominent');
            nextBtn.classList.remove('prominent');

            // Update image counter
            const totalQuestions = practicalData.validQuestions.length;
            document.querySelector('.image-counter').innerHTML = `Question <span id="current-question">${index + 1}</span> of ${totalQuestions}`;

            // Update answer sheet number highlighting
            document.querySelectorAll('.answer-number').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });

            // Preload adjacent images
            preloadAdjacentImages(index);
        }

        // preloadImage is now provided by js/question-renderer.js

        function preloadAdjacentImages(currentIndex) {
            if (!practicalData || !practicalData.validQuestions) return;

            // Preload previous image
            if (currentIndex > 0) {
                const prevQuestion = practicalData.validQuestions[currentIndex - 1];
                if (prevQuestion && prevQuestion.image) {
                    preloadImage(prevQuestion.image, preloadedImages);
                }
            }

            // Preload next image
            if (currentIndex < practicalData.validQuestions.length - 1) {
                const nextQuestion = practicalData.validQuestions[currentIndex + 1];
                if (nextQuestion && nextQuestion.image) {
                    preloadImage(nextQuestion.image, preloadedImages);
                }
            }
        }

        function goToImage(index) {
            if (practicalData && practicalData.validQuestions && index >= 0 && index < practicalData.validQuestions.length) {
                showImage(index);
            }
        }

        function showExtraCreditImage(extraCreditIndex) {
            if (!practicalData || !practicalData.extraCreditQuestions) return;

            const question = practicalData.extraCreditQuestions[extraCreditIndex];
            if (!question) return;

            // Update tracking variables
            isViewingExtraCredit = true;
            currentExtraCreditIndex = extraCreditIndex;

            // Update main image or text
            const imageElement = document.getElementById('current-image');
            imageElement.src = '';

            if (question.image) {
                // Image-based extra credit question
                const imagePath = `images/${question.image}`;
                imageElement.src = imagePath;
                imageElement.style.display = 'block';
                document.getElementById('current-question-text').innerHTML = question.question || 'Extra Credit Question';

                // Add click handler for full-size view on mobile
                imageElement.onclick = () => showFullImageModal(imagePath);
                imageElement.style.cursor = 'pointer';
                imageElement.title = 'Click to view full size';
            } else {
                // Text-only extra credit question
                imageElement.style.display = 'none';
                imageElement.onclick = null;
                imageElement.style.cursor = 'default';
                imageElement.title = '';

                // Get theme class
                const themeClass = getTextOnlyThemeClass(question.theme);

                document.getElementById('current-question-text').innerHTML = `
                    <div class="text-only-question-box ${themeClass}">
                        ${question.question || 'Extra Credit Question'}
                    </div>&nbsp;
                `;
            }

            // Update image counter for extra credit
            document.querySelector('.image-counter').innerHTML = `Extra Credit Question`;

            // Clear regular answer highlighting
            document.querySelectorAll('.answer-number').forEach(btn => {
                btn.classList.remove('active');
            });

            // Highlight extra credit button
            document.querySelectorAll('.extra-credit-button').forEach((btn, i) => {
                btn.classList.toggle('active', i === extraCreditIndex);
            });

            // Update inline answer section
            const inlineNumber = document.getElementById('inline-question-number');
            const inlineInput = document.getElementById('inline-answer-input');
            if (inlineNumber && inlineInput) {
                inlineNumber.textContent = 'EC';
                inlineInput.value = document.querySelector(`input[name="extra-credit-${extraCreditIndex}"]`).value || '';
                inlineInput.placeholder = 'Extra credit answer...';
            }

            // Update navigation buttons for extra credit
            const isLastExtraCredit = extraCreditIndex >= (practicalData.extraCreditQuestions.length - 1);
            document.getElementById('prev-btn').disabled = false; // Can always go back from EC
            document.getElementById('next-btn').disabled = isLastExtraCredit; // Disable if on last EC

            // Keep next button visible but disabled for extra credit
            const nextBtn = document.getElementById('next-btn');
            const submitBtn = document.getElementById('inline-submit-btn');
            nextBtn.style.display = 'block';
            submitBtn.style.display = 'none';

            // Clear any prominent styling (removed distracting styling)
            const prevBtn = document.getElementById('prev-btn');
            prevBtn.classList.remove('prominent');
            nextBtn.classList.remove('prominent');

            // Scroll to the image container and focus the inline input
            document.querySelector('.image-container').scrollIntoView({ behavior: 'smooth' });
            setTimeout(() => {
                document.getElementById('inline-answer-input').focus();
            }, 300);
        }

        function goToQuestionAndFocus(index) {
            if (practicalData && practicalData.validQuestions && index >= 0 && index < practicalData.validQuestions.length) {
                showImage(index);
                // Scroll to the image container
                document.querySelector('.image-container').scrollIntoView({ behavior: 'smooth' });
                // Focus the inline answer input after scrolling
                setTimeout(() => {
                    document.getElementById('inline-answer-input').focus();
                }, 300);
            }
        }

        let currentExtraCreditIndex = -1; // -1 means not viewing extra credit
        let isViewingExtraCredit = false;

        function previousImage() {
            if (isViewingExtraCredit) {
                if (currentExtraCreditIndex > 0) {
                    // Previous extra credit question
                    showExtraCreditImage(currentExtraCreditIndex - 1);
                } else {
                    // Go back to last regular question
                    isViewingExtraCredit = false;
                    currentExtraCreditIndex = -1;
                    const lastRegularIndex = practicalData && practicalData.validQuestions ? practicalData.validQuestions.length - 1 : 0;
                    showImage(lastRegularIndex);
                }
            } else if (currentImageIndex > 0) {
                showImage(currentImageIndex - 1);
            }
        }

        function nextImage() {
            const maxIndex = practicalData && practicalData.validQuestions ? practicalData.validQuestions.length - 1 : 0;
            const hasExtraCredit = practicalData && practicalData.extraCreditQuestions && practicalData.extraCreditQuestions.length > 0;

            if (isViewingExtraCredit) {
                const maxExtraCreditIndex = practicalData.extraCreditQuestions.length - 1;
                if (currentExtraCreditIndex < maxExtraCreditIndex) {
                    // Next extra credit question
                    showExtraCreditImage(currentExtraCreditIndex + 1);
                }
                // If at last extra credit, stay there (no wrap around)
            } else if (currentImageIndex < maxIndex) {
                showImage(currentImageIndex + 1);
            } else if (hasExtraCredit && currentImageIndex === maxIndex) {
                // At last regular question, move to first extra credit
                showExtraCreditImage(0);
            }

            // Focus the answer input after navigation
            setTimeout(() => {
                document.getElementById('inline-answer-input').focus();
            }, 0);
        }

        function submitPractical() {
            if (!practicalData || !practicalData.questions) return;

            // Build modal questions list for review (includes extra credit)
            buildModalQuestionsList(practicalData.validQuestions, true);

            // Grade regular questions using shared module
            const result = AnswerGrading.gradeQuestions({
                questions: practicalData.validQuestions,
                answerInputPrefix: 'answer',
                circleSelector: '.answer-number',
                showPartialCredit: true,
                warnBlanks: true,
                onQuestionClick: showQuestionPopup
            });

            // User cancelled submission
            if (!result) return;

            let { score, total } = result;
            let extraCreditScore = 0;

            // Grade extra credit questions if present
            if (practicalData.extraCreditQuestions && practicalData.extraCreditQuestions.length > 0) {
                const ecResult = AnswerGrading.gradeExtraCredit({
                    questions: practicalData.extraCreditQuestions,
                    answerInputPrefix: 'extra-credit-',
                    buttonSelector: '.extra-credit-button',
                    correctPoints: 2,
                    partialPoints: 1,
                    threshold: 0.8,
                    onQuestionClick: showQuestionPopup
                });

                extraCreditScore = ecResult.score;
            }

            // Clear all answer sheet highlighting
            AnswerGrading.clearHighlighting('.answer-number', '.extra-credit-button');

            // Display final score
            AnswerGrading.displayFinalScore({
                score,
                total,
                extraCreditScore,
                scoreElementId: 'final-score',
                submitButtonSelector: '.submit-button'
            });
        }

        function syncAnswer() {
            const inlineInput = document.getElementById('inline-answer-input');

            if (isViewingExtraCredit) {
                // Sync with extra credit input
                const extraCreditInput = document.querySelector(`input[name="extra-credit-${currentExtraCreditIndex}"]`);
                if (extraCreditInput) {
                    extraCreditInput.value = inlineInput.value;
                }
            } else {
                // Sync with regular answer input
                const currentQuestionNum = currentImageIndex + 1;
                const answerSheetInput = document.querySelector(`input[name="answer${currentQuestionNum}"]`);
                if (answerSheetInput) {
                    answerSheetInput.value = inlineInput.value;
                }
            }
        }

        function scrollToAnswerSheet() {
            document.querySelector('.answer-sheet').scrollIntoView({ behavior: 'smooth' });
        }

        function handleEnterKey(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent form submission
                nextImage(); // Move to next question
            }
        }

        function showFullImageModal(imagePath) {
            // Remove any existing modal
            const existingModal = document.querySelector('.full-image-modal');
            if (existingModal) {
                existingModal.remove();
            }

            // Create full image modal
            const modal = document.createElement('div');
            modal.className = 'full-image-modal';
            modal.innerHTML = `
                <div class="full-image-content">
                    <div class="full-image-header">
                        <button class="close-modal" onclick="this.parentElement.parentElement.parentElement.remove()">√ó</button>
                    </div>
                    <div class="full-image-container">
                        <img src="${imagePath}" alt="Full size image" class="full-size-image" />
                    </div>
                </div>
            `;

            // Add to page
            document.body.appendChild(modal);

            // Add click outside to close
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Modal functions now provided by js/question-modal.js
        // Store extra credit questions globally for the modal module
        window.extraCreditQuestions = [];

        function toggleQuestionDetail(questionNum) {
            const existingDetail = document.getElementById(`detail-${questionNum}`);
            if (existingDetail) {
                existingDetail.remove();
                return;
            }

            // Remove any other open details
            document.querySelectorAll('[id^="detail-"]').forEach(el => el.remove());

            if (!practicalData || !practicalData.questions) return;

            const question = practicalData.questions[questionNum - 1];
            if (!question) return;

            const detailDiv = document.createElement('div');
            detailDiv.id = `detail-${questionNum}`;
            detailDiv.className = 'question-detail';
            detailDiv.innerHTML = `
                <div class="detail-content">
                    <div class="detail-image">
                        <img src="images/${question.image}" alt="Question ${questionNum}" />
                    </div>
                    <div class="detail-info">
                        <strong>Question ${questionNum}:</strong> ${question.question || 'What is the tissue/structure?'}
                    </div>
                </div>
            `;

            // Insert after the results circles
            const resultsCircles = document.querySelector('.results-circles');
            resultsCircles.insertAdjacentElement('afterend', detailDiv);
        }

        // Smart arrow key navigation using shared helper
        document.addEventListener('keydown', function(event) {
            const inlineInput = document.getElementById('inline-answer-input');
            handleArrowKeyNavigation(event, inlineInput, (direction) => {
                if (direction === 'left') {
                    previousImage();
                } else {
                    nextImage();
                }
            });
        });

        // Dark mode functionality (now provided by js/theme-manager.js)
        // Will be initialized after loading the theme manager module

        // Load theme manager first (no dependencies)
        const themeScript = document.createElement('script');
        themeScript.src = 'js/theme-manager.js';
        themeScript.onload = () => {
            // Initialize theme manager
            ThemeManager.init();
        };
        document.head.appendChild(themeScript);

        // Load YAML parser, shared modules, pathway validator, and question modal module
        const yamlScript = document.createElement('script');
        yamlScript.src = 'https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js';
        yamlScript.onload = () => {
            const answerCheckerScript = document.createElement('script');
            answerCheckerScript.src = 'js/answer-checker.js';
            answerCheckerScript.onload = () => {
                const answerGradingScript = document.createElement('script');
                answerGradingScript.src = 'js/answer-grading.js';
                answerGradingScript.onload = () => {
                    const questionRendererScript = document.createElement('script');
                    questionRendererScript.src = 'js/question-renderer.js';
                    questionRendererScript.onload = () => {
                        const pathwayScript = document.createElement('script');
                        pathwayScript.src = 'js/pathway-validator.js';
                        pathwayScript.onload = () => {
                            const modalScript = document.createElement('script');
                            modalScript.src = 'js/question-modal.js';
                            modalScript.onload = async () => {
                                // Load pathway connection trees
                                await pathwayValidator.loadConnectionTrees();
                                loadPractical();
                            };
                            document.head.appendChild(modalScript);
                        };
                        document.head.appendChild(pathwayScript);
                    };
                    document.head.appendChild(questionRendererScript);
                };
                document.head.appendChild(answerGradingScript);
            };
            document.head.appendChild(answerCheckerScript);
        };
        document.head.appendChild(yamlScript);
    </script>
</body>
</html>
